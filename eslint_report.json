[{"filePath":"/Users/anilkaraca/Desktop/yeser/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/App.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Constants' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Text' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'View' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'supabase' is defined but never used. Allowed unused vars must match /^_/u.","line":25,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import 'react-native-url-polyfill/auto';\n\nimport {\n  DarkTheme as NavigationDarkTheme,\n  DefaultTheme,\n  LinkingOptions,\n  NavigationContainer,\n  NavigationState,\n} from '@react-navigation/native';\nimport Constants from 'expo-constants';\nimport * as Linking from 'expo-linking'; // Import expo-linking for the prefix\nimport { StatusBar, type StatusBarStyle } from 'expo-status-bar';\nimport React from 'react';\nimport { Text, View } from 'react-native'; // Added View, Text, Removed StyleSheet\n\nimport ThrowbackModal from './components/features/ThrowbackModal'; // Added for throwback\nimport RootNavigator from './navigation/RootNavigator';\nimport { ThemeProvider, useTheme } from './providers/ThemeProvider';\nimport SplashScreen from './screens/SplashScreen'; // Import SplashScreen\nimport { analyticsService } from './services/analyticsService';\nimport useAuthStore from './store/authStore'; // Corrected import for default export\nimport { ProfileState, useProfileStore } from './store/profileStore'; // Corrected import for named export and type\nimport { useThrowbackStore } from './store/throwbackStore'; // Added for throwback\nimport { RootStackParamList } from './types/navigation'; // Import RootStackParamList\nimport { supabase } from './utils/supabaseClient';\n\n// Define the linking configuration\n// Note: You'll need to create an EmailConfirmScreen and add it to your AuthNavigator\n// for the 'auth/confirm' path to work as intended.\n\n// Helper function to get the active route name\nconst getActiveRouteName = (\n  state: NavigationState | undefined\n): string | undefined => {\n  if (!state) {\n    return undefined;\n  }\n  const route = state.routes[state.index];\n\n  if (route.state) {\n    // Dive deeper\n    return getActiveRouteName(route.state as NavigationState);\n  }\n\n  return route.name;\n};\n\nconst linking: LinkingOptions<RootStackParamList> = {\n  prefixes: [Linking.createURL('/')],\n  config: {\n    // The `screens` object maps route names in RootStackParamList to their linking config\n    screens: {\n      Auth: {\n        // Config for the 'Auth' route (which is AuthNavigator)\n        path: 'auth', // URL prefix: yeserapp://auth\n        screens: {\n          // Screens within AuthNavigator (from AuthStackParamList)\n          // You will need to create an 'EmailConfirm' screen in your AuthNavigator.\n          EmailConfirm: 'confirm', // Deep link: yeserapp://auth/confirm\n          // Example for Login screen, if you add it to AuthStackParamList and want to deep link\n          // Login: 'login', // Deep link: yeserapp://auth/login\n        },\n      },\n      MainApp: {\n        // Config for the 'MainApp' route (which is MainAppNavigator)\n        path: 'app', // URL prefix: yeserapp://app\n        screens: {\n          // Screens within MainAppNavigator (now MainAppTabParamList)\n          HomeTab: 'home', // Deep link: yeserapp://app/home will go to the HomeTab\n          DailyEntryTab: 'new-entry', // Deep link: yeserapp://app/new-entry\n          PastEntriesTab: 'past-entries', // Deep link: yeserapp://app/past-entries\n          // Add other tabs here if they get deep links\n        },\n      },\n      // If you had a top-level screen in RootStackParamList like:\n      // NotFound: 'not-found', // Deep link: yeserapp://not-found\n    },\n  },\n};\n\nconst AppContent: React.FC = () => {\n  const { theme, currentThemeName } = useTheme();\n  const throwbackStore = useThrowbackStore();\n  const fetchRandomEntry = throwbackStore.fetchRandomEntry;\n  const isThrowbackVisible = throwbackStore.isThrowbackVisible; // Corrected: Use isThrowbackVisible\n  const randomThrowbackEntry = throwbackStore.randomEntry;\n\n  const isAuthenticated = useAuthStore(state => state.isAuthenticated); // Corrected: Removed parentheses\n  const profileId = useProfileStore((state: ProfileState) => state.id); // Check if profile is loaded by checking id\n  const routeNameRef = React.useRef<string | undefined>(undefined);\n\n  React.useEffect(() => {\n    analyticsService.logAppOpen();\n\n    // Only attempt to fetch throwback if user is authenticated and profile is loaded\n    if (isAuthenticated && profileId) {\n      // Simple 25% chance to show throwback on app content mount\n      // Consider making this configurable or based on user preferences later\n      if (Math.random() < 0.25) {\n        fetchRandomEntry();\n      }\n    }\n  }, [isAuthenticated, profileId, fetchRandomEntry]);\n\n  const navigationTheme = React.useMemo(\n    () => ({\n      ...(currentThemeName === 'dark' ? NavigationDarkTheme : DefaultTheme),\n      colors: {\n        ...(currentThemeName === 'dark'\n          ? NavigationDarkTheme.colors\n          : DefaultTheme.colors),\n        primary: theme.colors.primary,\n        background: theme.colors.background,\n        card: theme.colors.surface, // In many themes, 'card' maps to 'surface' or 'background'\n        text: theme.colors.text,\n        border: theme.colors.border, // Or theme.colors.outline if you have it\n        notification: theme.colors.primary, // Or theme.colors.error for error notifications\n      },\n    }),\n    [currentThemeName, theme] // Corrected: Removed DefaultTheme and NavigationDarkTheme from deps\n  );\n\n  const statusBarStyle: StatusBarStyle =\n    currentThemeName === 'dark' ? 'light' : 'dark';\n\n  return (\n    <NavigationContainer\n      theme={navigationTheme}\n      linking={linking}\n      fallback={<SplashScreen />}\n      onStateChange={state => {\n        // Corrected: Removed parentheses and added newline for block\n        const previousRouteName = routeNameRef.current;\n        const currentRouteName = getActiveRouteName(state);\n\n        if (previousRouteName !== currentRouteName && currentRouteName) {\n          analyticsService.logScreenView(currentRouteName);\n        }\n        routeNameRef.current = currentRouteName;\n      }}\n    >\n      <StatusBar style={statusBarStyle} />\n      <RootNavigator />\n      {randomThrowbackEntry && isThrowbackVisible && <ThrowbackModal />}\n    </NavigationContainer>\n  );\n};\n\nexport default function App() {\n  return (\n    <ThemeProvider>\n      <AppContent />\n    </ThemeProvider>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/api/gratitudeApi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/api/profileApi.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'id' is defined but never used. Allowed unused args must match /^_/u.","line":65,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":65,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ProfileState } from '../store/profileStore';\nimport { supabase } from '../utils/supabaseClient';\n\nexport type ProfileResponse = Omit<ProfileState, 'loading' | 'error'>;\n\n// Function to get the user's profile\nexport const getProfile = async (): Promise<ProfileResponse | null> => {\n  const { data: sessionData, error: sessionError } =\n    await supabase.auth.getSession();\n  if (sessionError || !sessionData.session) {\n    console.error('Error getting session or no active session:', sessionError);\n    throw sessionError || new Error('No active session');\n  }\n\n  const { user } = sessionData.session;\n  if (!user) {\n    throw new Error('No user found in session');\n  }\n\n  try {\n    const { data, error, status } = await supabase\n      .from('profiles')\n      .select(\n        'id, username, reminder_enabled, reminder_time, onboarded, throwback_reminder_enabled, throwback_reminder_frequency'\n      )\n      .eq('id', user.id)\n      .single();\n\n    if (error && status !== 406) {\n      // 406 status means no rows found, which is a valid case for a new user\n      console.error('Error fetching profile:', error);\n      throw error;\n    }\n\n    if (data) {\n      return data as ProfileResponse;\n    }\n    return null; // No profile found, could be a new user\n  } catch (error) {\n    console.error('Catch block error fetching profile:', error);\n    throw error;\n  }\n};\n\n// Function to update the user's profile\nexport const updateProfile = async (\n  profileUpdates: Partial<ProfileResponse>\n): Promise<ProfileResponse | null> => {\n  const { data: sessionData, error: sessionError } =\n    await supabase.auth.getSession();\n  if (sessionError || !sessionData.session) {\n    console.error('Error getting session or no active session:', sessionError);\n    throw sessionError || new Error('No active session');\n  }\n\n  const { user } = sessionData.session;\n  if (!user) {\n    throw new Error('No user found in session');\n  }\n\n  try {\n    const { data, error } = await supabase\n      .from('profiles')\n      .update({\n        ...(({ id, ...rest }) => rest)(profileUpdates), // Exclude 'id' from the update payload\n        updated_at: new Date().toISOString(), // Ensure updated_at is set\n      })\n      .eq('id', user.id)\n      .select(\n        'id, username, reminder_enabled, reminder_time, onboarded, throwback_reminder_enabled, throwback_reminder_frequency'\n      )\n      .single();\n\n    if (error) {\n      console.error('Error updating profile:', error);\n      throw error;\n    }\n\n    if (data) {\n      return data as ProfileResponse;\n    }\n    return null;\n  } catch (error) {\n    console.error('Catch block error updating profile:', error);\n    throw error;\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/components/SkeletonEntryItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/components/StreakVisual.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/components/ThemedButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/components/features/ThrowbackModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/hooks/useStreak.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1214,1217],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1214,1217],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useFocusEffect } from '@react-navigation/native';\nimport { useCallback, useState } from 'react';\n\nimport { getStreak } from '../api/gratitudeApi';\nimport { useProfileStore } from '../store/profileStore';\n\ninterface UseStreakReturn {\n  streak: number | null;\n  isLoading: boolean;\n  error: string | null;\n  fetchStreak: () => Promise<void>;\n}\n\nconst useStreak = (): UseStreakReturn => {\n  const setGlobalStreak = useProfileStore(state => state.setStreak);\n  const setGlobalStreakLoading = useProfileStore(\n    state => state.setStreakLoading\n  );\n  const setGlobalStreakError = useProfileStore(state => state.setStreakError);\n  const [streak, setStreak] = useState<number | null>(null);\n  const [isLoading, setIsLoading] = useState<boolean>(true); // Local loading for initial fetch or direct hook usage\n  const [error, setError] = useState<string | null>(null); // Local error for direct hook usage\n\n  const fetchStreakData = useCallback(async () => {\n    setIsLoading(true);\n    setGlobalStreakLoading(true);\n    setError(null);\n    setGlobalStreakError(null);\n    try {\n      const currentStreak = await getStreak();\n      setStreak(currentStreak);\n      setGlobalStreak(currentStreak);\n    } catch (e: any) {\n      console.error('Error fetching streak:', e);\n      const errorMessage = e.message || 'Seri bilgisi alınamadı.';\n      setError(errorMessage);\n      setGlobalStreakError(errorMessage);\n      setStreak(0); // Default to 0 on error for local state\n      setGlobalStreak(0); // Default to 0 on error for global state\n    } finally {\n      setIsLoading(false);\n      setGlobalStreakLoading(false);\n    }\n  }, [setGlobalStreak, setGlobalStreakLoading, setGlobalStreakError]);\n\n  useFocusEffect(\n    useCallback(() => {\n      fetchStreakData();\n    }, [fetchStreakData])\n  );\n\n  return { streak, isLoading, error, fetchStreak: fetchStreakData };\n};\n\nexport default useStreak;\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/navigation/AuthNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/navigation/RootNavigator.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getTabBarIcon' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":30,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2712,2715],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2712,2715],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'profileIsLoading' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":119,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":119,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'throwbackReminderEnabled' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":121,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":121,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'throwbackReminderFrequency' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":124,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":124,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fetchRandomEntry' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":129,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":129,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isThrowbackVisible' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":130,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":130,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lastThrowbackShownAt' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":133,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":133,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'canShowThrowback' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":148,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":148,"endColumn":25},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'initializeAuth'. Either include it or remove the dependency array.","line":173,"column":6,"nodeType":"ArrayExpression","endLine":173,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [initializeAuth]","fix":{"range":[6937,6939],"text":"[initializeAuth]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/navigation/RootNavigator.tsx\nimport { Ionicons } from '@expo/vector-icons'; // Import Ionicons\nimport { createBottomTabNavigator } from '@react-navigation/bottom-tabs';\nimport { createStackNavigator } from '@react-navigation/stack';\nimport React, { useEffect } from 'react';\n\nimport { useTheme } from '../providers/ThemeProvider'; // Assuming useTheme is here\nimport CalendarViewScreen from '../screens/CalendarViewScreen'; // Import CalendarViewScreen // Import SettingsScreen\nimport DailyEntryScreen from '../screens/DailyEntryScreen'; // Import DailyEntryScreen\nimport EntryDetailScreen from '../screens/EntryDetailScreen';\nimport HelpScreen from '../screens/HelpScreen'; // Import HelpScreen\nimport HomeScreen from '../screens/HomeScreen';\nimport OnboardingReminderSetupScreen from '../screens/onboarding/OnboardingReminderSetupScreen'; // Import OnboardingReminderSetupScreen\nimport OnboardingScreen from '../screens/onboarding/OnboardingScreen'; // Import OnboardingScreen\nimport PastEntriesScreen from '../screens/PastEntriesScreen'; // Import PastEntriesScreen\nimport PrivacyPolicyScreen from '../screens/PrivacyPolicyScreen'; // Import PrivacyPolicyScreen\nimport ReminderSettingsScreen from '../screens/ReminderSettingsScreen'; // Import ReminderSettingsScreen\nimport SettingsScreen from '../screens/SettingsScreen';\nimport SplashScreen from '../screens/SplashScreen'; // Import SplashScreen\nimport TermsOfServiceScreen from '../screens/TermsOfServiceScreen'; // Import TermsOfServiceScreen\nimport useAuthStore from '../store/authStore';\nimport { useProfileStore } from '../store/profileStore';\nimport { useThrowbackStore } from '../store/throwbackStore'; // Added import\nimport { MainAppTabParamList, RootStackParamList } from '../types/navigation'; // Updated to MainAppTabParamList\nimport AuthNavigator from './AuthNavigator';\n\n// Define the Main App Tab Navigator\nconst Tab = createBottomTabNavigator<MainAppTabParamList>();\n\nconst getTabBarIcon = (\n  routeName: string,\n  focused: boolean,\n  color: string,\n  size: number\n) => {\n  let iconName;\n  switch (routeName) {\n    case 'HomeTab':\n      iconName = focused ? 'home' : 'home-outline';\n      break;\n    case 'DailyEntryTab':\n      iconName = focused ? 'add-circle' : 'add-circle-outline';\n      break;\n    case 'PastEntriesTab':\n      iconName = focused ? 'list' : 'list-outline';\n      break;\n    case 'CalendarTab': // Added case for CalendarTab\n      iconName = focused ? 'calendar' : 'calendar-outline';\n      break;\n    case 'SettingsTab':\n      iconName = focused ? 'settings' : 'settings-outline';\n      break;\n    default:\n      iconName = 'ellipse-outline'; // Default icon\n      break;\n  }\n  return <Ionicons name={iconName as any} size={size} color={color} />;\n};\nconst MainAppNavigator: React.FC = () => {\n  const { theme } = useTheme();\n  return (\n    <Tab.Navigator\n      screenOptions={{\n        tabBarActiveTintColor: theme.colors.primary,\n        tabBarInactiveTintColor: theme.colors.onSurfaceVariant,\n        tabBarStyle: {\n          backgroundColor: theme.colors.surface,\n          borderTopColor: theme.colors.outlineVariant, // Optional: for a subtle top border\n        },\n        headerStyle: {\n          backgroundColor: theme.colors.surface, // For screens within tabs that might show a header\n        },\n        headerTintColor: theme.colors.onSurface,\n        headerTitleStyle: {\n          fontFamily: theme.typography.titleMedium.fontFamily, // Example: Using a theme font\n        },\n      }}\n    >\n      <Tab.Screen\n        name=\"HomeTab\"\n        component={HomeScreen}\n        options={{ title: 'Ana Sayfa' }} // Turkish title for Home tab\n      />\n      <Tab.Screen\n        name=\"DailyEntryTab\"\n        component={DailyEntryScreen}\n        options={{ title: 'Yeni Kayıt' }} // Turkish title for Daily Entry tab\n      />\n      <Tab.Screen\n        name=\"PastEntriesTab\"\n        component={PastEntriesScreen}\n        options={{ title: 'Geçmiş Kayıtlar' }} // Turkish title for Past Entries tab\n      />\n      <Tab.Screen\n        name=\"CalendarTab\"\n        component={CalendarViewScreen}\n        options={{ title: 'Takvim' }}\n      />\n      <Tab.Screen\n        name=\"SettingsTab\"\n        component={SettingsScreen}\n        options={{ title: 'Ayarlar' }} // Turkish title for Settings tab\n      />\n      {/* Add other main app tabs here */}\n    </Tab.Navigator>\n  );\n};\n\n// Define the Root Stack that switches between Auth, MainApp, and Loading\nconst Root = createStackNavigator<RootStackParamList>();\n\nconst RootNavigator: React.FC = () => {\n  const { theme } = useTheme(); // Moved useTheme to the top\n  const isAuthenticated = useAuthStore(state => state.isAuthenticated);\n  const authIsLoading = useAuthStore(state => state.isLoading);\n  const initializeAuth = useAuthStore(state => state.initializeAuth);\n  const profileId = useProfileStore(state => state.id);\n  const onboarded = useProfileStore(state => state.onboarded);\n  const profileIsLoading = useProfileStore(state => state.loading);\n  const fetchProfile = useProfileStore(state => state.fetchProfile);\n  const throwbackReminderEnabled = useProfileStore(\n    state => state.throwback_reminder_enabled\n  );\n  const throwbackReminderFrequency = useProfileStore(\n    state => state.throwback_reminder_frequency\n  );\n\n  // Throwback store integration\n  const fetchRandomEntry = useThrowbackStore(state => state.fetchRandomEntry);\n  const isThrowbackVisible = useThrowbackStore(\n    state => state.isThrowbackVisible\n  );\n  const lastThrowbackShownAt = useThrowbackStore(\n    state => state.lastThrowbackShownAt\n  );\n\n  // Effect to fetch profile data when user is authenticated and profile is not yet loaded\n  // This is a simplified fetch trigger; a more robust solution might involve profileApi.getProfile\n  // and setting it in the store, which should happen after login/auth state change.\n  useEffect(() => {\n    if (isAuthenticated && !profileId) {\n      // Use selected profileId\n      // console.log('RootNavigator: Authenticated and profileId not found, calling fetchProfile...');\n      fetchProfile();\n    }\n  }, [isAuthenticated, profileId, fetchProfile]); // fetchProfile should be stable if defined correctly in store\n\n  const canShowThrowback = (\n    lastShownAt: number | null,\n    frequency: 'daily' | 'weekly' | 'monthly' | string\n  ): boolean => {\n    if (!lastShownAt) return true; // Always show if never shown before\n\n    const now = Date.now();\n    const diffHours = (now - lastShownAt) / (1000 * 60 * 60);\n\n    switch (frequency) {\n      case 'daily':\n        return diffHours >= 24;\n      case 'weekly':\n        return diffHours >= 24 * 7;\n      case 'monthly':\n        return diffHours >= 24 * 30; // Approximation for a month\n      default:\n        return true; // Default to allow if frequency is unknown or not set\n    }\n  };\n\n  useEffect(() => {\n    initializeAuth();\n\n    // Call initializeAuth only once on mount as its definition is stable.\n  }, []); // Empty dependency array ensures this runs only once on mount\n\n  // Show splash screen if auth is loading, or if user is authenticated but profile ID is not yet loaded.\n  if (authIsLoading || (isAuthenticated && !profileId)) {\n    // Use selected profileId\n    // console.log(`Splash conditions: authIsLoading=${authIsLoading}, isAuthenticated=${isAuthenticated}, profile.id=${profile.id}`);\n    return <SplashScreen />;\n  }\n  return (\n    <Root.Navigator\n      screenOptions={{\n        headerShown: false, // Default for most root screens\n        headerStyle: {\n          backgroundColor: theme.colors.surface,\n        },\n        headerTintColor: theme.colors.onSurface,\n        headerTitleStyle: {\n          fontFamily: theme.typography.titleLarge.fontFamily, // Example for stack navigator titles\n          fontSize: theme.typography.titleLarge.fontSize,\n        },\n      }}\n    >\n      {!isAuthenticated ? (\n        <Root.Screen name=\"Auth\" component={AuthNavigator} />\n      ) : !onboarded ? ( // Use selected onboarded status\n        // User is authenticated but not onboarded - show the onboarding flow\n        // This group will handle the two-step onboarding\n        <Root.Group>\n          <Root.Screen name=\"Onboarding\" component={OnboardingScreen} />\n          <Root.Screen\n            name=\"OnboardingReminderSetup\"\n            component={OnboardingReminderSetupScreen}\n          />\n        </Root.Group>\n      ) : (\n        // User is authenticated and onboarded\n        <Root.Screen name=\"MainApp\" component={MainAppNavigator} />\n      )}\n      {/* ReminderSettingsScreen is available in the stack but needs a navigation trigger */}\n      <Root.Screen\n        name=\"ReminderSettings\"\n        component={ReminderSettingsScreen}\n        options={{ headerShown: true, title: 'Hatırlatıcı Ayarları' }}\n      />\n      <Root.Screen\n        name=\"EntryDetail\"\n        component={EntryDetailScreen}\n        options={{ headerShown: true, title: 'Detay' }}\n      />\n      <Root.Screen\n        name=\"PrivacyPolicy\"\n        component={PrivacyPolicyScreen}\n        options={{ headerShown: true, title: 'Gizlilik Politikası' }}\n      />\n      <Root.Screen\n        name=\"TermsOfService\"\n        component={TermsOfServiceScreen}\n        options={{ headerShown: true, title: 'Kullanım Koşulları' }}\n      />\n      <Root.Screen\n        name=\"Help\"\n        component={HelpScreen}\n        options={{ headerShown: true, title: 'Yardım ve SSS' }}\n      />\n      {/* Settings screen is now a tab */}\n    </Root.Navigator>\n  );\n};\n\nexport default RootNavigator;\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/providers/ThemeProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/screens/CalendarViewScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useEffect' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GratitudeEntry' is defined but never used. Allowed unused vars must match /^_/u.","line":25,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":17},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":63,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2236,2239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2236,2239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":99,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":99,"endColumn":17},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3271,3274],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3271,3274],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useEffect, useState } from 'react';\nimport { ActivityIndicator, Alert, StyleSheet, Text, View } from 'react-native';\nimport { Calendar, DateData } from 'react-native-calendars';\n\n// Define a more specific type for our marked dates object\nexport type CustomMarkedDates = {\n  [key: string]: {\n    marked?: boolean;\n    dotColor?: string;\n    activeOpacity?: number;\n    disableTouchEvent?: boolean;\n  };\n};\nimport { BottomTabNavigationProp } from '@react-navigation/bottom-tabs';\nimport {\n  CompositeNavigationProp,\n  useFocusEffect,\n  useNavigation,\n} from '@react-navigation/native';\nimport { NativeStackNavigationProp } from '@react-navigation/native-stack';\n\nimport {\n  getEntryDatesForMonth,\n  getGratitudeEntryByDate,\n  GratitudeEntry,\n} from '../api/gratitudeApi';\nimport { useTheme } from '../providers/ThemeProvider';\nimport { AppTheme } from '../themes/types';\nimport { MainAppTabParamList, RootStackParamList } from '../types/navigation';\n\ntype CalendarViewScreenNavigationProp = CompositeNavigationProp<\n  BottomTabNavigationProp<MainAppTabParamList, 'CalendarTab'>, // Assuming 'CalendarTab' will be the route name\n  NativeStackNavigationProp<RootStackParamList>\n>;\n\nconst CalendarViewScreen = () => {\n  const navigation = useNavigation<CalendarViewScreenNavigationProp>();\n  const { theme } = useTheme();\n  const styles = createStyles(theme);\n\n  const [currentMonth, setCurrentMonth] = useState(new Date());\n  const [markedDates, setMarkedDates] = useState<CustomMarkedDates>({});\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const fetchMarkedDates = useCallback(\n    async (date: Date) => {\n      setIsLoading(true);\n      setError(null);\n      try {\n        const year = date.getFullYear();\n        const month = date.getMonth() + 1; // Month is 1-indexed for API\n        const entryDates = await getEntryDatesForMonth(year, month);\n\n        const newMarkedDates: CustomMarkedDates = {};\n        entryDates.forEach(entryDate => {\n          newMarkedDates[entryDate] = {\n            marked: true,\n            dotColor: theme.colors.primary,\n          };\n        });\n        setMarkedDates(newMarkedDates);\n      } catch (e: any) {\n        console.error('Error fetching marked dates:', e);\n        setError(e.message || 'Takvim verileri alınırken bir hata oluştu.');\n        setMarkedDates({});\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [theme.colors.primary]\n  );\n\n  useFocusEffect(\n    useCallback(() => {\n      fetchMarkedDates(currentMonth);\n    }, [fetchMarkedDates, currentMonth])\n  );\n\n  const handleMonthChange = (dateData: DateData) => {\n    const newDate = new Date(dateData.year, dateData.month - 1, 1);\n    setCurrentMonth(newDate);\n    fetchMarkedDates(newDate);\n  };\n\n  const handleDayPress = async (day: DateData) => {\n    if (markedDates[day.dateString]?.marked) {\n      setIsLoading(true);\n      try {\n        const entry = await getGratitudeEntryByDate(day.dateString);\n        if (entry) {\n          navigation.navigate('EntryDetail', { entry });\n        } else {\n          Alert.alert(\n            'Kayıt Bulunamadı',\n            'Bu tarih için bir şükran kaydı bulunamadı.'\n          );\n        }\n      } catch (e: any) {\n        Alert.alert('Hata', 'Kayıt detayları alınırken bir sorun oluştu.');\n      } finally {\n        setIsLoading(false);\n      }\n    }\n  };\n\n  return (\n    <View style={styles.container}>\n      <Calendar\n        current={currentMonth.toISOString().split('T')[0]} // Initial date for calendar\n        onMonthChange={handleMonthChange}\n        onDayPress={handleDayPress}\n        markedDates={markedDates}\n        markingType={'dot'}\n        monthFormat={'yyyy MMMM'} // Turkish month format if locale is set up correctly\n        theme={{\n          backgroundColor: theme.colors.background,\n          calendarBackground: theme.colors.background,\n          textSectionTitleColor: theme.colors.textSecondary,\n          selectedDayBackgroundColor: theme.colors.primary,\n          selectedDayTextColor: theme.colors.onPrimary,\n          todayTextColor: theme.colors.primary,\n          dayTextColor: theme.colors.text,\n          textDisabledColor: theme.colors.disabled,\n          dotColor: theme.colors.primary,\n          selectedDotColor: theme.colors.onPrimary,\n          arrowColor: theme.colors.primary,\n          disabledArrowColor: theme.colors.disabled,\n          monthTextColor: theme.colors.text,\n          indicatorColor: theme.colors.primary,\n          textDayFontFamily: theme.typography.body1.fontFamily,\n          textMonthFontFamily: theme.typography.h2.fontFamily,\n          textDayHeaderFontFamily: theme.typography.caption.fontFamily,\n          textDayFontSize: theme.typography.body1.fontSize,\n          textMonthFontSize: theme.typography.h2.fontSize,\n          textDayHeaderFontSize: theme.typography.caption.fontSize,\n        }}\n      />\n      {isLoading && (\n        <View style={styles.loadingOverlay}>\n          <ActivityIndicator size=\"large\" color={theme.colors.primary} />\n        </View>\n      )}\n      {error && <Text style={styles.errorText}>{error}</Text>}\n    </View>\n  );\n};\n\nconst createStyles = (theme: AppTheme) =>\n  StyleSheet.create({\n    container: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n    },\n    loadingOverlay: {\n      ...StyleSheet.absoluteFillObject,\n      backgroundColor: 'rgba(0,0,0,0.1)',\n      justifyContent: 'center',\n      alignItems: 'center',\n    },\n    errorText: {\n      textAlign: 'center',\n      color: theme.colors.error,\n      padding: theme.spacing.medium,\n      backgroundColor: theme.colors.surface,\n    },\n  });\n\nexport default CalendarViewScreen;\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/screens/DailyEntryScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NavigationProp' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GratitudeEntry' is defined but never used. Allowed unused vars must match /^_/u.","line":25,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":17},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":153,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4505,4508],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4505,4508],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":176,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":176,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5461,5464],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5461,5464],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import DateTimePicker, {\n  DateTimePickerEvent,\n} from '@react-native-community/datetimepicker';\nimport {\n  NavigationProp,\n  RouteProp,\n  useNavigation,\n} from '@react-navigation/native';\nimport { StackNavigationProp } from '@react-navigation/stack';\nimport React, { Fragment, useEffect, useState } from 'react';\nimport {\n  Alert,\n  Platform,\n  ScrollView,\n  StyleSheet,\n  Text,\n  TextInput,\n  TouchableOpacity,\n  View,\n} from 'react-native';\n\nimport {\n  addGratitudeEntry,\n  getGratitudeEntryByDate,\n  GratitudeEntry,\n  updateGratitudeEntry,\n} from '../api/gratitudeApi';\nimport ThemedButton from '../components/ThemedButton';\nimport { useTheme } from '../providers/ThemeProvider';\nimport { analyticsService } from '../services/analyticsService';\nimport { AppTheme } from '../themes/types';\nimport { RootStackParamList } from '../types/navigation';\n\ntype DailyEntryScreenRouteProp = RouteProp<RootStackParamList, 'DailyEntry'>;\n\ninterface Props {\n  route?: DailyEntryScreenRouteProp;\n}\n\nconst DailyEntryScreen: React.FC<Props> = ({ route }) => {\n  const { theme } = useTheme();\n  const styles = createStyles(theme);\n\n  const [items, setItems] = useState<string[]>(['']);\n  const [entryDate, setEntryDate] = useState(new Date());\n  const [showDatePicker, setShowDatePicker] = useState(false);\n  const [focusedInputIndex, setFocusedInputIndex] = useState<number | null>(\n    null\n  );\n  const [isLoading, setIsLoading] = useState(false);\n  const navigation =\n    useNavigation<StackNavigationProp<RootStackParamList, 'DailyEntry'>>();\n\n  const entryToEdit = route?.params?.entryToEdit;\n  const isEditMode = !!entryToEdit;\n  const entryId = entryToEdit?.id;\n\n  useEffect(() => {\n    if (isEditMode && entryToEdit) {\n      setItems(entryToEdit.content ? entryToEdit.content.split('\\n') : ['']);\n      if (entryToEdit.entry_date) {\n        const dateParts = entryToEdit.entry_date.split('-');\n        if (dateParts.length === 3) {\n          setEntryDate(\n            new Date(\n              parseInt(dateParts[0]),\n              parseInt(dateParts[1]) - 1,\n              parseInt(dateParts[2])\n            )\n          );\n        } else {\n          setEntryDate(new Date(entryToEdit.entry_date));\n        }\n      }\n    }\n  }, [isEditMode, entryToEdit]);\n\n  const handleItemChange = (text: string, index: number) => {\n    const newItems = [...items];\n    newItems[index] = text;\n    setItems(newItems);\n  };\n\n  const addItemInput = () => {\n    setItems([...items, '']);\n  };\n\n  const removeItemInput = (index: number) => {\n    if (items.length > 1) {\n      const newItems = items.filter((_, i) => i !== index);\n      setItems(newItems);\n    }\n  };\n\n  const handleDateChange = (\n    event: DateTimePickerEvent,\n    selectedDate?: Date\n  ) => {\n    const currentDate = selectedDate || entryDate;\n    setShowDatePicker(Platform.OS === 'ios');\n    setEntryDate(currentDate);\n  };\n\n  const showDatepicker = () => {\n    setShowDatePicker(true);\n  };\n\n  const formatDate = (date: Date) => {\n    return date.toLocaleDateString('tr-TR', {\n      day: '2-digit',\n      month: '2-digit',\n      year: 'numeric',\n    });\n  };\n\n  const handleSaveEntry = async () => {\n    const nonEmptyItems = items\n      .map(item => item.trim())\n      .filter(item => item !== '');\n    if (nonEmptyItems.length === 0) {\n      Alert.alert('Eksik Bilgi', 'Lütfen en az bir şükran metni girin.');\n      return;\n    }\n    const entryText = nonEmptyItems.join('\\n');\n    setIsLoading(true);\n\n    // Define isoDate here to make it accessible in the catch block for the \"Edit\" logic\n    const isoDate = entryDate.toISOString().split('T')[0];\n\n    try {\n      if (isEditMode && entryId) {\n        await updateGratitudeEntry(entryId, {\n          content: entryText,\n          entry_date: isoDate,\n        });\n        analyticsService.logEvent('gratitude_entry_updated', {\n          entry_length: entryText.length,\n          entry_id: entryId,\n        });\n        Alert.alert('Başarılı', 'Şükran kaydınız güncellendi!', [\n          { text: 'Tamam', onPress: () => navigation.goBack() },\n        ]);\n      } else {\n        await addGratitudeEntry({ content: entryText, entry_date: isoDate });\n        analyticsService.logEvent('gratitude_entry_saved', {\n          entry_length: entryText.length,\n        });\n        Alert.alert('Başarılı', 'Şükran kaydınız eklendi!', [\n          { text: 'Tamam', onPress: () => navigation.goBack() },\n        ]);\n        setItems(['']); // Reset items only for new entries, not for edits\n      }\n    } catch (error: any) {\n      if (error && typeof error.code === 'string' && error.code === '23505') {\n        Alert.alert(\n          'Kayıt Mevcut',\n          'Bu tarih için zaten bir şükran kaydınız mevcut. Mevcut kaydı düzenleyebilir veya farklı bir tarih seçebilirsiniz.',\n          [\n            {\n              text: 'Düzenle',\n              onPress: async () => {\n                try {\n                  setIsLoading(true);\n                  const existingEntry = await getGratitudeEntryByDate(isoDate);\n                  setIsLoading(false);\n                  if (existingEntry) {\n                    navigation.replace('DailyEntry', {\n                      entryToEdit: existingEntry,\n                    });\n                  } else {\n                    Alert.alert(\n                      'Hata',\n                      'Düzenlenecek mevcut kayıt bulunamadı. Lütfen tekrar deneyin.'\n                    );\n                  }\n                } catch (fetchError: any) {\n                  setIsLoading(false);\n                  console.error('Error fetching entry for edit:', fetchError);\n                  Alert.alert(\n                    'Hata',\n                    'Mevcut kayıt getirilirken bir sorun oluştu.'\n                  );\n                }\n              },\n            },\n            {\n              text: 'Farklı Tarih Seç',\n              style: 'cancel',\n            },\n          ]\n        );\n      } else {\n        console.error(\n          `Error ${isEditMode ? 'updating' : 'saving'} gratitude entry:`,\n          error\n        );\n        Alert.alert(\n          'Hata',\n          error.message ||\n            `Şükran kaydı ${isEditMode ? 'güncellenirken' : 'eklenirken'} bir hata oluştu.`\n        );\n      }\n    }\n    setIsLoading(false);\n  };\n\n  return (\n    <ScrollView\n      style={styles.scrollView}\n      contentContainerStyle={styles.container}\n    >\n      <Text style={styles.title}>\n        {isEditMode ? 'Kaydı Düzenle' : 'Bugün Neler İçin Minnettarsın?'}\n      </Text>\n\n      <Text style={styles.label}>Tarih:</Text>\n      <ThemedButton\n        variant=\"outline\"\n        onPress={showDatepicker}\n        title={formatDate(entryDate)}\n        style={styles.dateButton}\n      />\n      {showDatePicker && (\n        <DateTimePicker\n          testID=\"dateTimePicker\"\n          value={entryDate}\n          mode=\"date\"\n          is24Hour={true}\n          display={Platform.OS === 'ios' ? 'spinner' : 'default'}\n          onChange={handleDateChange}\n          // Consider theming options for DateTimePicker if available or needed\n        />\n      )}\n\n      <Text style={styles.label}>Minnet Metinleri:</Text>\n      {items.map((item, index) => (\n        <Fragment key={index}>\n          <View style={styles.itemRow}>\n            <TextInput\n              style={[\n                styles.itemInput,\n                focusedInputIndex === index && styles.itemInputFocused,\n              ]}\n              multiline\n              placeholder={`Şükran #${index + 1}`}\n              placeholderTextColor={theme.colors.textSecondary}\n              value={item}\n              onChangeText={text => handleItemChange(text, index)}\n              onFocus={() => setFocusedInputIndex(index)}\n              onBlur={() => setFocusedInputIndex(null)}\n            />\n            {items.length > 1 && (\n              <TouchableOpacity\n                onPress={() => removeItemInput(index)}\n                style={styles.removeButton}\n                activeOpacity={0.7}\n              >\n                <Text style={styles.removeButtonText}>X</Text>\n              </TouchableOpacity>\n            )}\n          </View>\n        </Fragment>\n      ))}\n      <ThemedButton\n        variant=\"ghost\"\n        onPress={addItemInput}\n        title=\"(+) Şükran Ekle\"\n        style={styles.addButton}\n      />\n      <View style={styles.saveButtonContainer}>\n        <ThemedButton\n          variant=\"primary\"\n          title={isEditMode ? 'Güncelle' : 'Kaydet'}\n          onPress={handleSaveEntry}\n          isLoading={isLoading}\n          disabled={isLoading}\n        />\n      </View>\n    </ScrollView>\n  );\n};\n\nconst createStyles = (theme: AppTheme) =>\n  StyleSheet.create({\n    scrollView: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n    },\n    container: {\n      padding: theme.spacing.medium,\n    },\n    title: {\n      ...theme.typography.h2,\n      color: theme.colors.text,\n      marginBottom: theme.spacing.large,\n      textAlign: 'center',\n    },\n    label: {\n      ...theme.typography.label,\n      color: theme.colors.textSecondary,\n      marginBottom: theme.spacing.small,\n      marginTop: theme.spacing.medium,\n    },\n    itemRow: {\n      flexDirection: 'row',\n      alignItems: 'center',\n      marginBottom: theme.spacing.medium,\n    },\n    itemInput: {\n      flex: 1,\n      borderWidth: 1,\n      borderColor: theme.colors.border,\n      backgroundColor: theme.colors.inputBackground,\n      color: theme.colors.inputText,\n      paddingHorizontal: theme.spacing.medium,\n      paddingVertical: theme.spacing.small,\n      fontSize: theme.typography.body1.fontSize,\n      fontFamily: theme.typography.body1.fontFamily,\n      borderRadius: theme.borderRadius.medium,\n      marginRight: theme.spacing.small,\n      minHeight: 50,\n      textAlignVertical: 'top',\n    },\n    itemInputFocused: {\n      borderColor: theme.colors.primary,\n      // Optionally, add a subtle shadow or slightly thicker border for more emphasis\n      // shadowColor: theme.colors.primary,\n      // shadowOffset: { width: 0, height: 0 },\n      // shadowOpacity: 0.3,\n      // shadowRadius: 2,\n      // elevation: 3, // For Android\n      // borderWidth: 1.5, // If you want a thicker border\n    },\n    removeButton: {\n      padding: theme.spacing.small,\n      backgroundColor: theme.colors.danger,\n      borderRadius: theme.borderRadius.medium,\n      justifyContent: 'center',\n      alignItems: 'center',\n      minWidth: 36,\n      minHeight: 36,\n    },\n    removeButtonText: {\n      color: theme.colors.onDanger,\n      fontWeight: 'bold',\n      fontSize: theme.typography.caption.fontSize, // Using caption size for consistency\n    },\n    addButton: {\n      marginTop: theme.spacing.small, // Reduced margin as it's a ghost button\n      alignSelf: 'flex-start', // Align to left or center as preferred\n    },\n    addButtonText: {\n      // ThemedButton will handle its text style based on variant, but can be overridden\n      // color: theme.colors.primary, // Example if direct styling needed\n      // fontWeight: 'bold', // Example\n    },\n    saveButtonContainer: {\n      marginTop: theme.spacing.large,\n      marginBottom: theme.spacing.medium, // Add some bottom margin\n    },\n    dateButton: {\n      // Specific styles for the date ThemedButton if needed\n      // e.g., to match input field height or alignment\n      paddingVertical: theme.spacing.small, // Match input padding\n    },\n    dateButtonText: {\n      // To ensure date text color matches general input text or desired style\n      // color: theme.colors.text, // Removed as ThemedButton handles its text color\n    },\n  });\n\nexport default DailyEntryScreen;\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/screens/EntryDetailScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2534,2537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2534,2537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CompositeNavigationProp, RouteProp } from '@react-navigation/native'; // useNavigation removed as it's passed via props\nimport { NativeStackNavigationProp } from '@react-navigation/native-stack';\nimport React, { useState } from 'react';\nimport {\n  ActivityIndicator,\n  Alert,\n  ScrollView,\n  StyleSheet,\n  Text,\n  View,\n} from 'react-native';\n\nimport { deleteGratitudeEntry } from '../api/gratitudeApi';\nimport ThemedButton from '../components/ThemedButton';\nimport { useTheme } from '../providers/ThemeProvider';\nimport { AppTheme } from '../themes/types';\nimport { RootStackParamList } from '../types/navigation';\n\n// Define the type for the route params\ntype EntryDetailScreenRouteProp = RouteProp<RootStackParamList, 'EntryDetail'>;\n\n// Define navigation prop type for navigating back or to an edit screen\ntype EntryDetailScreenNavigationProp = CompositeNavigationProp<\n  NativeStackNavigationProp<RootStackParamList, 'EntryDetail'>,\n  NativeStackNavigationProp<RootStackParamList>\n>;\n\ninterface Props {\n  route: EntryDetailScreenRouteProp;\n  navigation: EntryDetailScreenNavigationProp;\n}\n\nconst EntryDetailScreen: React.FC<Props> = ({ route, navigation }) => {\n  const { theme } = useTheme();\n  const styles = createStyles(theme);\n\n  const [isDeleting, setIsDeleting] = useState(false);\n  const { entry } = route.params;\n\n  const gratitudeItems = entry.content\n    ? entry.content.split('\\n').filter(item => item.trim() !== '')\n    : [];\n\n  const formattedDate = entry.created_at\n    ? new Date(entry.created_at).toLocaleDateString('tr-TR', {\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit',\n      })\n    : 'Tarih bilgisi yok';\n\n  const handleEdit = () => {\n    navigation.navigate('DailyEntry', { entryToEdit: entry });\n  };\n\n  const handleDelete = async () => {\n    Alert.alert(\n      'Kaydı Sil',\n      'Bu şükran kaydını silmek istediğinizden emin misiniz?',\n      [\n        {\n          text: 'İptal',\n          style: 'cancel',\n        },\n        {\n          text: 'Sil',\n          style: 'destructive',\n          onPress: async () => {\n            if (!entry.id) {\n              Alert.alert('Hata', 'Kayıt ID bulunamadı.');\n              return;\n            }\n            setIsDeleting(true);\n            try {\n              await deleteGratitudeEntry(entry.id);\n              Alert.alert('Başarılı', 'Kayıt silindi.', [\n                { text: 'Tamam', onPress: () => navigation.goBack() },\n              ]);\n            } catch (error: any) {\n              console.error('Error deleting entry:', error);\n              Alert.alert(\n                'Hata',\n                error.message || 'Kayıt silinirken bir hata oluştu.'\n              );\n            }\n            setIsDeleting(false);\n          },\n        },\n      ],\n      { cancelable: true }\n    );\n  };\n\n  return (\n    <ScrollView style={styles.container}>\n      <View style={styles.headerContainer}>\n        <Text style={styles.dateText}>{formattedDate}</Text>\n      </View>\n      <View style={styles.contentContainer}>\n        {gratitudeItems.length > 0 ? (\n          gratitudeItems.map((item, index) => (\n            <View key={index} style={styles.itemContainer}>\n              <Text style={styles.bulletPoint}>•</Text>\n              <Text style={styles.contentText}>{item}</Text>\n            </View>\n          ))\n        ) : (\n          <Text style={styles.contentText}>{'İçerik bulunamadı.'}</Text>\n        )}\n      </View>\n\n      {isDeleting ? (\n        <ActivityIndicator\n          size=\"large\"\n          color={theme.colors.error}\n          style={styles.loader}\n        />\n      ) : (\n        <View style={styles.actionsContainer}>\n          <View style={styles.buttonWrapper}>\n            <ThemedButton\n              title=\"Düzenle\"\n              onPress={handleEdit}\n              variant=\"secondary\"\n            />\n          </View>\n          <View style={styles.buttonWrapper}>\n            <ThemedButton title=\"Sil\" onPress={handleDelete} variant=\"danger\" />\n          </View>\n        </View>\n      )}\n    </ScrollView>\n  );\n};\n\nconst createStyles = (theme: AppTheme) =>\n  StyleSheet.create({\n    container: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n      padding: theme.spacing.medium,\n    },\n    headerContainer: {\n      marginBottom: theme.spacing.large,\n      paddingBottom: theme.spacing.medium,\n      borderBottomWidth: 1,\n      borderBottomColor: theme.colors.border,\n    },\n    dateText: {\n      ...theme.typography.h3,\n      color: theme.colors.primary, // Or theme.colors.text\n      textAlign: 'center',\n    },\n    contentContainer: {\n      backgroundColor: theme.colors.surface, // Or theme.colors.card\n      borderRadius: theme.borderRadius.medium,\n      padding: theme.spacing.medium,\n      // Consider using theme.shadows if defined, or adjust for theme\n      shadowColor: '#000', // Changed from theme.colors.shadow\n      shadowOffset: { width: 0, height: 1 },\n      shadowOpacity: 0.2,\n      shadowRadius: 1.41,\n      elevation: 2,\n    },\n    itemContainer: {\n      flexDirection: 'row',\n      alignItems: 'flex-start',\n      marginBottom: theme.spacing.small,\n    },\n    bulletPoint: {\n      ...theme.typography.body1,\n      color: theme.colors.primary, // Or theme.colors.textAccent\n      marginRight: theme.spacing.small,\n      fontWeight: 'bold', // Keep or integrate into typography style\n    },\n    contentText: {\n      ...theme.typography.body1,\n      color: theme.colors.text,\n      flexShrink: 1, // Ensure text wraps within the container\n    },\n    actionsContainer: {\n      flexDirection: 'row',\n      justifyContent: 'space-around',\n      marginTop: theme.spacing.large, // Changed from theme.spacing.xlarge\n      paddingVertical: theme.spacing.medium,\n      borderTopWidth: 1,\n      borderTopColor: theme.colors.border,\n    },\n    buttonWrapper: {\n      flex: 1,\n      marginHorizontal: theme.spacing.small,\n    },\n    loader: {\n      marginTop: theme.spacing.large,\n    },\n  });\n\nexport default EntryDetailScreen;\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/screens/HelpScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/screens/HomeScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useEffect' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useState' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Button' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GratitudeEntry' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3202,3205],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3202,3205],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/screens/HomeScreen.tsx\nimport { BottomTabScreenProps } from '@react-navigation/bottom-tabs';\nimport { StackNavigationProp } from '@react-navigation/stack';\nimport React, { useEffect, useState } from 'react';\nimport { TouchableOpacity } from 'react-native';\nimport {\n  ActivityIndicator,\n  Button,\n  StyleSheet,\n  Text,\n  View,\n} from 'react-native';\n\nimport { GratitudeEntry } from '../api/gratitudeApi'; // getRandomGratitudeEntry will be called by the store\nimport ThrowbackModal from '../components/features/ThrowbackModal';\nimport StreakVisual from '../components/StreakVisual'; // Import StreakVisual\nimport useStreak from '../hooks/useStreak';\nimport { useTheme } from '../providers/ThemeProvider'; // Import useTheme\nimport { useProfileStore } from '../store/profileStore';\nimport { useThrowbackStore } from '../store/throwbackStore';\nimport { MainAppTabParamList, RootStackParamList } from '../types/navigation';\n\ntype HomeScreenNavigationProp = StackNavigationProp<RootStackParamList>;\n\ntype Props = BottomTabScreenProps<MainAppTabParamList, 'HomeTab'>;\n\nconst HomeScreen: React.FC<Props> = ({ navigation }) => {\n  const { theme } = useTheme(); // Get theme\n  const styles = createStyles(theme); // Create styles with theme\n  useStreak(); // Initialize the hook to fetch streak and update store\n  const streak = useProfileStore(state => state.streak);\n  const streakLoading = useProfileStore(state => state.streakLoading);\n  const streakError = useProfileStore(state => state.streakError);\n\n  // Local state for spark/random entry is now managed by useThrowbackStore\n  const {\n    fetchRandomEntry: fetchThrowbackEntry,\n    showThrowback,\n    isLoading: isThrowbackLoading,\n    error: throwbackError,\n    // randomEntry: currentThrowbackEntry, // We can get this if needed for direct checks\n  } = useThrowbackStore();\n\n  const handleFetchAndShowThrowback = async () => {\n    await fetchThrowbackEntry();\n    // Check if an error occurred during fetch (the store updates its 'error' state)\n    // If no error, the modal will show the entry. The modal itself checks for randomEntry from the store.\n    // We can directly call showThrowback, as the modal visibility is controlled by isThrowbackVisible in the store.\n    // The ThrowbackModal component itself will only render if randomEntry exists and isThrowbackVisible is true.\n    if (!useThrowbackStore.getState().error) {\n      // Check store directly for error post-fetch\n      showThrowback();\n    }\n  };\n  return (\n    <View style={styles.container}>\n      <Text style={styles.title}>Yeşer Gratitude App</Text>\n      <Text style={styles.subtitle}>Ana Sayfa</Text>\n      <View style={styles.streakContainer}>\n        {streakLoading ? (\n          <ActivityIndicator size=\"large\" color={theme.colors.primary} />\n        ) : streakError ? (\n          <Text style={styles.streakErrorText}>\n            Seri yüklenemedi: {streakError}\n          </Text>\n        ) : (\n          <StreakVisual streakCount={streak ?? 0} />\n        )}\n      </View>\n      {/* Other HomeScreen content will go here */}\n      <TouchableOpacity\n        style={styles.button}\n        onPress={() =>\n          (navigation.getParent<HomeScreenNavigationProp>() as any).navigate(\n            'ReminderSettings'\n          )\n        }\n        activeOpacity={0.7}\n      >\n        <Text style={styles.buttonText}>Hatırlatıcı Ayarları</Text>\n      </TouchableOpacity>\n\n      <TouchableOpacity\n        style={styles.sparkButton}\n        onPress={handleFetchAndShowThrowback}\n        disabled={isThrowbackLoading}\n        activeOpacity={0.7}\n      >\n        {isThrowbackLoading ? (\n          <ActivityIndicator size=\"small\" color={theme.colors.onPrimary} />\n        ) : (\n          <Text style={styles.sparkButtonText}>✨ Anı Pırıltısı Getir</Text>\n        )}\n      </TouchableOpacity>\n      {throwbackError && <Text style={styles.errorText}>{throwbackError}</Text>}\n\n      <ThrowbackModal />\n    </View>\n  );\n};\n\nimport { AppTheme } from '../themes/types'; // Import AppTheme\n\nconst createStyles = (theme: AppTheme) =>\n  StyleSheet.create({\n    container: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n      backgroundColor: theme.colors.background, // Use theme color\n    },\n    title: {\n      ...theme.typography.h1,\n      color: theme.colors.primary, // Use theme color\n      marginBottom: theme.spacing.small,\n    },\n    subtitle: {\n      ...theme.typography.h3,\n      color: theme.colors.secondary, // Use theme color\n      marginBottom: theme.spacing.large,\n    },\n    streakContainer: {\n      marginTop: theme.spacing.large,\n      alignItems: 'center',\n    },\n    streakText: {\n      ...theme.typography.body1,\n      color: theme.colors.text,\n      textAlign: 'center',\n    },\n    button: {\n      marginTop: theme.spacing.large,\n      backgroundColor: theme.colors.secondary,\n      paddingVertical: theme.spacing.medium,\n      paddingHorizontal: theme.spacing.xl,\n      borderRadius: theme.borderRadius.medium,\n      alignItems: 'center',\n    },\n    buttonText: {\n      ...theme.typography.button,\n      color: theme.colors.onSecondary,\n    },\n    streakErrorText: {\n      ...theme.typography.caption,\n      color: theme.colors.error,\n      marginTop: theme.spacing.small,\n    },\n    sparkButton: {\n      marginTop: theme.spacing.medium,\n      backgroundColor: theme.colors.accent,\n      paddingVertical: theme.spacing.medium,\n      paddingHorizontal: theme.spacing.xl,\n      borderRadius: theme.borderRadius.medium,\n      flexDirection: 'row',\n      alignItems: 'center',\n      justifyContent: 'center',\n    },\n    sparkButtonText: {\n      ...theme.typography.button,\n      color: theme.colors.onPrimary, // Assuming accent has good contrast with onPrimary, or define onAccent\n      marginLeft: theme.spacing.small,\n    },\n    errorText: {\n      ...theme.typography.caption,\n      color: theme.colors.error,\n      marginTop: theme.spacing.small,\n      textAlign: 'center',\n    },\n  });\n\nexport default HomeScreen;\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/screens/LoginScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/screens/PastEntriesScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ActivityIndicator' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1601,1604],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1601,1604],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BottomTabNavigationProp } from '@react-navigation/bottom-tabs';\nimport {\n  CompositeNavigationProp,\n  useNavigation,\n} from '@react-navigation/native';\nimport { useFocusEffect } from '@react-navigation/native';\nimport { NativeStackNavigationProp } from '@react-navigation/native-stack';\nimport React, { useCallback, useState } from 'react';\nimport {\n  ActivityIndicator,\n  FlatList,\n  RefreshControl,\n  StyleSheet,\n  Text,\n  TouchableOpacity,\n  View,\n} from 'react-native';\n\nimport { getGratitudeEntries, GratitudeEntry } from '../api/gratitudeApi';\nimport SkeletonEntryItem from '../components/SkeletonEntryItem';\nimport { useTheme } from '../providers/ThemeProvider';\nimport { AppTheme } from '../themes/types';\nimport { MainAppTabParamList, RootStackParamList } from '../types/navigation';\n\n// Define navigation prop types\ntype PastEntriesScreenNavigationProp = CompositeNavigationProp<\n  BottomTabNavigationProp<MainAppTabParamList, 'PastEntriesTab'>,\n  NativeStackNavigationProp<RootStackParamList>\n>;\n\nconst PastEntriesScreen = () => {\n  const navigation = useNavigation<PastEntriesScreenNavigationProp>();\n  const { theme } = useTheme();\n  const styles = createStyles(theme);\n\n  const [entries, setEntries] = useState<GratitudeEntry[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [refreshing, setRefreshing] = useState(false);\n\n  const fetchEntries = async () => {\n    try {\n      setError(null);\n      const fetchedEntries = await getGratitudeEntries();\n      setEntries(fetchedEntries);\n    } catch (e: any) {\n      console.error('Error fetching past entries:', e);\n      setError(e.message || 'Geçmiş kayıtlar alınırken bir hata oluştu.');\n    } finally {\n      setIsLoading(false);\n      setRefreshing(false);\n    }\n  };\n\n  useFocusEffect(\n    useCallback(() => {\n      setIsLoading(true);\n      fetchEntries();\n    }, [])\n  );\n\n  const onRefresh = useCallback(() => {\n    setRefreshing(true);\n    fetchEntries();\n  }, []);\n\n  const handleEntryPress = (entry: GratitudeEntry) => {\n    navigation.navigate('EntryDetail', { entry });\n  };\n\n  const renderItem = ({ item }: { item: GratitudeEntry }) => (\n    <TouchableOpacity\n      style={styles.entryItem}\n      onPress={() => handleEntryPress(item)}\n      activeOpacity={0.7}\n    >\n      <Text style={styles.entryDate}>\n        {(item.created_at\n          ? new Date(item.created_at)\n          : new Date(item.entry_date)\n        ).toLocaleDateString('tr-TR', {\n          day: '2-digit',\n          month: '2-digit',\n          year: 'numeric',\n        })}\n      </Text>\n      <Text style={styles.entryTextSnippet} numberOfLines={2}>\n        {item.content}\n      </Text>\n    </TouchableOpacity>\n  );\n\n  if (isLoading && !refreshing) {\n    // Show 3-5 skeleton items during initial load\n    const skeletonItems = Array.from({ length: 4 }); // Or any number you prefer e.g. 3 or 5\n    return (\n      <View style={styles.listContainer}>\n        <FlatList\n          data={skeletonItems}\n          renderItem={() => <SkeletonEntryItem />}\n          keyExtractor={(_, index) => `skeleton-${index}`}\n          contentContainerStyle={styles.listContentContainer}\n          scrollEnabled={false} // Disable scroll for skeleton list\n        />\n      </View>\n    );\n  }\n\n  if (error) {\n    return (\n      <View style={styles.centeredContainer}>\n        <Text style={styles.errorText}>{error}</Text>\n      </View>\n    );\n  }\n\n  if (entries.length === 0) {\n    return (\n      <View style={styles.centeredContainer}>\n        <Text style={styles.emptyStateText}>\n          Henüz şükran kaydınız bulunmuyor.\n        </Text>\n        <Text style={styles.emptyStateText}>\n          \"Yeni Kayıt\" sekmesinden ekleyebilirsiniz.\n        </Text>\n      </View>\n    );\n  }\n\n  return (\n    <FlatList\n      data={entries}\n      renderItem={renderItem}\n      keyExtractor={item => item.id || item.entry_date}\n      style={styles.listContainer}\n      contentContainerStyle={styles.listContentContainer}\n      refreshControl={\n        <RefreshControl\n          refreshing={refreshing}\n          onRefresh={onRefresh}\n          tintColor={theme.colors.primary} // iOS\n          colors={[theme.colors.primary]} // Android\n        />\n      }\n    />\n  );\n};\n\nconst createStyles = (theme: AppTheme) =>\n  StyleSheet.create({\n    centeredContainer: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n      padding: theme.spacing.large,\n      backgroundColor: theme.colors.background,\n    },\n    listContainer: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n    },\n    listContentContainer: {\n      padding: theme.spacing.medium,\n    },\n    entryItem: {\n      backgroundColor: theme.colors.surface,\n      padding: theme.spacing.medium,\n      borderRadius: theme.borderRadius.medium,\n      marginBottom: theme.spacing.medium,\n      shadowColor: theme.colors.shadow,\n      shadowOffset: { width: 0, height: 1 },\n      shadowOpacity: 0.1,\n      shadowRadius: 2,\n      elevation: 2,\n    },\n    entryDate: {\n      ...theme.typography.body1,\n      fontWeight: 'bold', // Maintained from original styling\n      color: theme.colors.primary,\n      marginBottom: theme.spacing.small,\n    },\n    entryTextSnippet: {\n      ...theme.typography.body2,\n      color: theme.colors.textSecondary,\n    },\n    errorText: {\n      ...theme.typography.body1,\n      color: theme.colors.error,\n      textAlign: 'center',\n    },\n    loadingText: {\n      ...theme.typography.body1,\n      color: theme.colors.textSecondary,\n      marginTop: theme.spacing.medium,\n    },\n    emptyStateText: {\n      ...theme.typography.body1,\n      color: theme.colors.textSecondary,\n      textAlign: 'center',\n      marginBottom: theme.spacing.small,\n    },\n  });\n\nexport default PastEntriesScreen;\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/screens/PrivacyPolicyScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PrivacyPolicyScreenNavigationProp' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":39},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":1,"message":"An empty interface declaration allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowInterfaces' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":12,"column":11,"nodeType":"Identifier","messageId":"noEmptyInterface","endLine":12,"endColumn":16,"suggestions":[{"messageId":"replaceEmptyInterface","data":{"replacement":"object"},"fix":{"range":[412,520],"text":"type Props = object"},"desc":"Replace empty interface with `object`."},{"messageId":"replaceEmptyInterface","data":{"replacement":"unknown"},"fix":{"range":[412,520],"text":"type Props = unknown"},"desc":"Replace empty interface with `unknown`."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { StackNavigationProp } from '@react-navigation/stack';\nimport React from 'react';\nimport { ScrollView, StyleSheet, Text, View } from 'react-native';\n\nimport { RootStackParamList } from '../types/navigation'; // Assuming you might add it to a stack\n\ntype PrivacyPolicyScreenNavigationProp = StackNavigationProp<\n  RootStackParamList,\n  'PrivacyPolicy' // Assuming 'PrivacyPolicy' will be a route name\n>;\n\ninterface Props {\n  // navigation: PrivacyPolicyScreenNavigationProp; // Uncomment if navigation is needed\n}\n\nconst PrivacyPolicyScreen: React.FC<Props> = (/*{ navigation }*/) => {\n  return (\n    <ScrollView style={styles.container}>\n      <View style={styles.contentContainer}>\n        <Text style={styles.title}>Gizlilik Politikası</Text>\n\n        <Text style={styles.lastUpdated}>Son Güncelleme: [GG/AA/YYYY]</Text>\n\n        <Text style={styles.heading}>Giriş</Text>\n        <Text style={styles.paragraph}>\n          Yeşer (\"biz\", \"bizim\" veya \"uygulama\") olarak gizliliğinize değer\n          veriyoruz. Bu Gizlilik Politikası, Yeşer mobil uygulamasını\n          kullandığınızda bilgilerinizi nasıl topladığımızı, kullandığımızı,\n          açıkladığımızı ve koruduğumuzu açıklamaktadır. Lütfen bu gizlilik\n          politikasını dikkatlice okuyun. Bu gizlilik politikasının şartlarını\n          kabul etmiyorsanız, lütfen uygulamaya erişmeyin.\n        </Text>\n\n        <Text style={styles.heading}>Bilgilerinizin Toplanması</Text>\n        <Text style={styles.paragraph}>\n          Uygulamayı kullandığınızda sizden çeşitli şekillerde bilgi\n          toplayabiliriz. Uygulama aracılığıyla toplayabileceğimiz bilgiler\n          şunları içerir:\n        </Text>\n        <Text style={styles.listItem}>\n          - Kişisel Veriler: E-posta adresiniz, kullanıcı adınız gibi gönüllü\n          olarak bize verdiğiniz kişisel kimlik bilgileri.\n        </Text>\n        <Text style={styles.listItem}>\n          - Minnettarlık Günlüğü Verileri: Uygulamaya girdiğiniz minnettarlık\n          kayıtlarınız. Bu veriler hesabınızla ilişkilendirilir ve güvenli bir\n          şekilde saklanır.\n        </Text>\n        <Text style={styles.listItem}>\n          - Kullanım Verileri: Uygulamadaki özelliklerle nasıl etkileşimde\n          bulunduğunuz gibi otomatik olarak toplanan bilgiler.\n        </Text>\n\n        <Text style={styles.heading}>Bilgilerinizin Kullanımı</Text>\n        <Text style={styles.paragraph}>\n          Hakkınızda doğru bilgilere sahip olmak, size sorunsuz, verimli ve\n          özelleştirilmiş bir deneyim sunmamızı sağlar. Özellikle, uygulama\n          aracılığıyla hakkınızda toplanan bilgileri şu amaçlarla\n          kullanabiliriz:\n        </Text>\n        <Text style={styles.listItem}>\n          - Hesabınızı oluşturmak ve yönetmek.\n        </Text>\n        <Text style={styles.listItem}>\n          - Size minnettarlık günlüğü özelliklerini sunmak.\n        </Text>\n        <Text style={styles.listItem}>\n          - Uygulamayı iyileştirmek ve kullanıcı deneyimini kişiselleştirmek.\n        </Text>\n        <Text style={styles.listItem}>\n          - Kullanım ve eğilimleri analiz etmek.\n        </Text>\n\n        <Text style={styles.heading}>Bilgilerinizin Açıklanması</Text>\n        <Text style={styles.paragraph}>\n          Aşağıdaki durumlar dışında bilgilerinizi herhangi bir üçüncü tarafa\n          satmayız, dağıtmayız veya kiralamayız:\n        </Text>\n        <Text style={styles.listItem}>\n          - Yasalar Gerektirdiğinde: Yasal süreçlere yanıt vermek, potansiyel\n          politika ihlallerini araştırmak veya haklarımızı, mülkiyetimizi ve\n          güvenliğimizi korumak için bilgi açıklamasının gerekli olduğuna\n          inandığımızda.\n        </Text>\n        <Text style={styles.listItem}>\n          - Hizmet Sağlayıcılar: Veri depolama veya müşteri hizmetleri gibi\n          bizim adımıza hizmet veren üçüncü taraf hizmet sağlayıcılarla. Bu\n          hizmet sağlayıcıların bilgilerinizi korumaları ve yalnızca bizim\n          adımıza hizmet vermek için kullanmaları gerekmektedir.\n        </Text>\n\n        <Text style={styles.heading}>Bilgilerinizin Güvenliği</Text>\n        <Text style={styles.paragraph}>\n          Bilgilerinizi korumak için idari, teknik ve fiziksel güvenlik\n          önlemleri kullanıyoruz. Makul önlemler alsak da, hiçbir güvenlik\n          önleminin mükemmel veya aşılmaz olmadığını ve hiçbir veri aktarım\n          yönteminin herhangi bir müdahaleye veya başka tür bir kötüye kullanıma\n          karşı garanti edilemeyeceğini lütfen unutmayın.\n        </Text>\n\n        <Text style={styles.heading}>Çocukların Gizliliği</Text>\n        <Text style={styles.paragraph}>\n          13 yaşın altındaki çocuklardan bilerek kişisel kimlik bilgileri\n          toplamıyoruz. Ebeveyn veya vasi iseniz ve çocuğunuzun bize kişisel\n          bilgiler verdiğini fark ederseniz, lütfen bizimle iletişime geçin.\n        </Text>\n\n        <Text style={styles.heading}>\n          Bu Gizlilik Politikasındaki Değişiklikler\n        </Text>\n        <Text style={styles.paragraph}>\n          Bu Gizlilik Politikasını zaman zaman güncelleyebiliriz. Bu sayfada\n          yeni Gizlilik Politikasını yayınlayarak herhangi bir değişikliği size\n          bildireceğiz. Herhangi bir değişiklik için bu Gizlilik Politikasını\n          periyodik olarak gözden geçirmeniz önerilir.\n        </Text>\n\n        <Text style={styles.heading}>Bize Ulaşın</Text>\n        <Text style={styles.paragraph}>\n          Bu Gizlilik Politikası hakkında herhangi bir sorunuz veya yorumunuz\n          varsa, lütfen bizimle iletişime geçin: [E-posta Adresiniz Buraya]\n        </Text>\n      </View>\n    </ScrollView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#F8F9FA', // Light background for readability\n  },\n  contentContainer: {\n    padding: 20,\n  },\n  title: {\n    fontSize: 26,\n    fontWeight: 'bold',\n    color: '#2F5233', // Dark green from your theme\n    marginBottom: 15,\n    textAlign: 'center',\n  },\n  lastUpdated: {\n    fontSize: 12,\n    color: '#6c757d', // Muted color for less emphasis\n    textAlign: 'center',\n    marginBottom: 20,\n  },\n  heading: {\n    fontSize: 20,\n    fontWeight: 'bold',\n    color: '#386641', // Medium green from your theme\n    marginTop: 20,\n    marginBottom: 10,\n  },\n  paragraph: {\n    fontSize: 16,\n    lineHeight: 24,\n    color: '#343a40', // Dark gray for body text\n    marginBottom: 10,\n    textAlign: 'justify',\n  },\n  listItem: {\n    fontSize: 16,\n    lineHeight: 24,\n    color: '#343a40',\n    marginBottom: 5,\n    marginLeft: 10, // Indent list items\n    textAlign: 'justify',\n  },\n});\n\nexport default PrivacyPolicyScreen;\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/screens/ReminderSettingsScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":103,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3341,3344],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3341,3344],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import DateTimePicker, {\n  DateTimePickerEvent,\n} from '@react-native-community/datetimepicker';\nimport React, { useEffect, useState } from 'react';\nimport {\n  Alert,\n  Platform,\n  StyleSheet,\n  Switch,\n  Text,\n  TouchableOpacity,\n  View,\n} from 'react-native';\n\nimport { updateProfile } from '../api/profileApi';\nimport ThemedButton from '../components/ThemedButton';\nimport { useTheme } from '../providers/ThemeProvider';\nimport {\n  cancelAllScheduledNotifications,\n  requestNotificationPermissions,\n  scheduleDailyReminder,\n} from '../services/notificationService';\nimport { useProfileStore } from '../store/profileStore';\nimport { AppTheme } from '../themes/types';\n\nconst ReminderSettingsScreen: React.FC = () => {\n  const { theme } = useTheme();\n  const styles = createStyles(theme);\n\n  const storeReminderEnabled = useProfileStore(state => state.reminder_enabled);\n  const storeReminderTime = useProfileStore(state => state.reminder_time);\n  const setProfile = useProfileStore(state => state.setProfile);\n  const setProfileLoading = useProfileStore(state => state.setLoading);\n\n  const [reminderEnabled, setReminderEnabled] = useState(storeReminderEnabled);\n  const [reminderTime, setReminderTime] = useState(new Date());\n  const [showTimePicker, setShowTimePicker] = useState(false);\n\n  useEffect(() => {\n    if (storeReminderTime) {\n      const [hours, minutes, seconds] = storeReminderTime\n        .split(':')\n        .map(Number);\n      const initialTime = new Date();\n      initialTime.setHours(hours, minutes, seconds);\n      setReminderTime(initialTime);\n    }\n    setReminderEnabled(storeReminderEnabled);\n  }, [storeReminderTime, storeReminderEnabled]);\n\n  const handleTimeChange = (\n    event: DateTimePickerEvent,\n    selectedDate?: Date\n  ) => {\n    setShowTimePicker(Platform.OS === 'ios');\n    if (selectedDate) {\n      setReminderTime(selectedDate);\n    }\n  };\n\n  const formatTime = (date: Date): string => {\n    return `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}:${String(date.getSeconds()).padStart(2, '0')}`;\n  };\n\n  const handleSaveSettings = async () => {\n    setProfileLoading(true);\n    const formattedTime = formatTime(reminderTime);\n    let finalReminderEnabled = reminderEnabled;\n\n    try {\n      if (reminderEnabled) {\n        const permissionGranted = await requestNotificationPermissions();\n        if (permissionGranted) {\n          const hour = reminderTime.getHours();\n          const minute = reminderTime.getMinutes();\n          await scheduleDailyReminder(\n            hour,\n            minute,\n            'Günlük Minnettarlık Zamanı',\n            'Bugün neleri fark ettin? Yazmaya ne dersin?'\n          );\n        } else {\n          Alert.alert(\n            'İzin Reddedildi',\n            'Bildirim izni verilmediği için hatırlatıcılar ayarlanamadı.'\n          );\n          finalReminderEnabled = false;\n          setReminderEnabled(false);\n        }\n      } else {\n        await cancelAllScheduledNotifications();\n      }\n\n      await updateProfile({\n        reminder_enabled: finalReminderEnabled,\n        reminder_time: formattedTime,\n      });\n      setProfile({\n        reminder_enabled: finalReminderEnabled,\n        reminder_time: formattedTime,\n      });\n      Alert.alert('Başarılı', 'Hatırlatıcı ayarları güncellendi.');\n    } catch (error: any) {\n      console.error('Hatırlatıcı ayarları güncellenemedi:', error);\n      Alert.alert('Hata', error.message || 'Ayarlar güncellenemedi.');\n    } finally {\n      setProfileLoading(false);\n    }\n  };\n\n  return (\n    <View style={styles.container}>\n      <Text style={styles.title}>Hatırlatıcı Ayarları</Text>\n\n      <View style={styles.settingRow}>\n        <Text style={styles.settingLabel}>Günlük Hatırlatıcı</Text>\n        <Switch\n          trackColor={{\n            false: theme.colors.border,\n            true: theme.colors.primary,\n          }}\n          thumbColor={\n            reminderEnabled ? theme.colors.onPrimary : theme.colors.surface\n          }\n          ios_backgroundColor={theme.colors.border}\n          onValueChange={setReminderEnabled}\n          value={reminderEnabled}\n        />\n      </View>\n\n      <View style={styles.settingRow}>\n        <Text style={styles.settingLabel}>Hatırlatma Saati</Text>\n        <TouchableOpacity\n          onPress={() => setShowTimePicker(true)}\n          disabled={!reminderEnabled}\n          activeOpacity={0.7}\n        >\n          <Text\n            style={[styles.timeText, !reminderEnabled && styles.disabledText]}\n          >\n            {formatTime(reminderTime).substring(0, 5)}\n          </Text>\n        </TouchableOpacity>\n      </View>\n\n      {showTimePicker && (\n        <DateTimePicker\n          testID=\"dateTimePicker\"\n          value={reminderTime}\n          mode=\"time\"\n          is24Hour={true}\n          display=\"spinner\"\n          onChange={handleTimeChange}\n          themeVariant={theme.name === 'dark' ? 'dark' : 'light'}\n        />\n      )}\n\n      <ThemedButton\n        title=\"Ayarları Kaydet\"\n        onPress={handleSaveSettings}\n        variant=\"primary\"\n        style={styles.saveButton}\n      />\n    </View>\n  );\n};\n\nconst createStyles = (theme: AppTheme) =>\n  StyleSheet.create({\n    container: {\n      flex: 1,\n      padding: theme.spacing.large,\n      backgroundColor: theme.colors.background,\n    },\n    title: {\n      ...theme.typography.h2,\n      color: theme.colors.primary,\n      marginBottom: theme.spacing.xl,\n      textAlign: 'center',\n    },\n    settingRow: {\n      flexDirection: 'row',\n      justifyContent: 'space-between',\n      alignItems: 'center',\n      marginBottom: theme.spacing.large,\n      paddingVertical: theme.spacing.medium,\n      borderBottomWidth: 1,\n      borderBottomColor: theme.colors.border,\n    },\n    settingLabel: {\n      ...theme.typography.body1,\n      color: theme.colors.text,\n    },\n    timeText: {\n      ...theme.typography.body1,\n      color: theme.colors.primary, // Or theme.colors.accent\n    },\n    disabledText: {\n      color: theme.colors.disabled,\n    },\n    saveButton: {\n      marginTop: theme.spacing.xl,\n    },\n  });\n\nexport default ReminderSettingsScreen;\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/screens/SettingsScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useCallback' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'parseTimeToDate' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":104,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":104,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":193,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7222,7225],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7222,7225],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getCurrentFrequencyLabel' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":205,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":205,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Ionicons } from '@expo/vector-icons';\nimport DateTimePicker, {\n  DateTimePickerEvent,\n} from '@react-native-community/datetimepicker';\nimport { Picker } from '@react-native-picker/picker';\nimport { BottomTabNavigationProp } from '@react-navigation/bottom-tabs';\nimport { useNavigation } from '@react-navigation/native';\nimport { StackNavigationProp } from '@react-navigation/stack';\nimport React, { useCallback, useEffect, useState } from 'react';\nimport {\n  ActivityIndicator,\n  Alert,\n  Platform,\n  ScrollView,\n  StyleSheet,\n  Text,\n  TouchableOpacity,\n  View,\n} from 'react-native';\nimport Switch from 'toggle-switch-react-native';\n\nimport ThemedButton from '../components/ThemedButton';\nimport { useTheme } from '../providers/ThemeProvider';\nimport { analyticsService } from '../services/analyticsService';\nimport useAuthStore from '../store/authStore'; // Import auth store\nimport { useProfileStore } from '../store/profileStore'; // Import profile store\nimport { useThrowbackStore } from '../store/throwbackStore'; // Import throwback store\nimport { MainAppTabParamList, RootStackParamList } from '../types/navigation';\n\n// Define frequency options for clarity, mapping machine values to human-readable Turkish text\nconst frequencyOptions: { label: string; value: string }[] = [\n  { label: 'Günlük', value: 'daily' },\n  { label: 'Haftalık', value: 'weekly' },\n  { label: 'Aylık', value: 'monthly' },\n];\n\ntype SettingsScreenNavigationProp = BottomTabNavigationProp<\n  MainAppTabParamList,\n  'SettingsTab'\n>;\n\nconst SettingsScreen = () => {\n  const navigation = useNavigation<SettingsScreenNavigationProp>();\n  const {\n    throwback_reminder_enabled,\n    throwback_reminder_frequency,\n    loading: profileLoading, // Loading state from the store (for fetching profile)\n    error: profileError, // Error state from the store\n    fetchProfile,\n    updateThrowbackPreferences,\n    reminder_enabled,\n    reminder_time,\n    updateDailyReminderSettings,\n  } = useProfileStore();\n\n  const { theme, toggleTheme } = useTheme();\n  const styles = createStyles(theme);\n\n  const authLogout = useAuthStore(state => state.logout);\n  const resetProfile = useProfileStore(state => state.resetProfile);\n  const resetThrowback = useThrowbackStore(state => state.resetThrowback);\n\n  // Local UI state for managing changes before they are saved to the store\n  const [uiIsThrowbackEnabled, setUiIsThrowbackEnabled] = useState(\n    throwback_reminder_enabled\n  );\n  const [uiThrowbackFrequency, setUiThrowbackFrequency] = useState(\n    throwback_reminder_frequency\n  );\n\n  // UI state for Daily Reminders\n  const [uiIsDailyReminderEnabled, setUiIsDailyReminderEnabled] =\n    useState(reminder_enabled);\n  const [uiDailyReminderTime, setUiDailyReminderTime] = useState(\n    reminder_time\n      ? new Date(`1970-01-01T${reminder_time}`)\n      : new Date(new Date().setHours(20, 0, 0, 0))\n  );\n  const [showDailyTimePicker, setShowDailyTimePicker] = useState(false);\n\n  // State for the save button's loading indicator\n  const [isSaving, setIsSaving] = useState(false);\n\n  useEffect(() => {\n    setUiIsThrowbackEnabled(throwback_reminder_enabled);\n  }, [throwback_reminder_enabled]);\n\n  useEffect(() => {\n    setUiThrowbackFrequency(throwback_reminder_frequency);\n  }, [throwback_reminder_frequency]);\n\n  useEffect(() => {\n    setUiIsDailyReminderEnabled(reminder_enabled);\n  }, [reminder_enabled]);\n\n  useEffect(() => {\n    setUiDailyReminderTime(\n      reminder_time\n        ? new Date(`1970-01-01T${reminder_time}`)\n        : new Date(new Date().setHours(20, 0, 0, 0))\n    );\n  }, [reminder_time]);\n\n  const parseTimeToDate = (timeStr: string) =>\n    new Date(`1970-01-01T${timeStr}`);\n  const formatTimeToString = (date: Date) =>\n    date.toTimeString().split(' ')[0].substring(0, 5); // HH:MM\n\n  const onDailyTimeChange = (\n    event: DateTimePickerEvent,\n    selectedDate?: Date\n  ) => {\n    const currentDate = selectedDate || uiDailyReminderTime;\n    setShowDailyTimePicker(Platform.OS === 'ios'); // Keep open on iOS until user dismisses\n    setUiDailyReminderTime(currentDate);\n    if (event.type === 'set') {\n      // 'set' means user confirmed the time\n      // analyticsService.logEvent('daily_reminder_time_changed', { // Already logged in handleSave\n      //   time: formatTimeToString(currentDate),\n      // });\n    } else {\n      // 'dismissed' or other event types\n    }\n  };\n\n  const hasChanges =\n    uiIsThrowbackEnabled !== throwback_reminder_enabled ||\n    (uiIsThrowbackEnabled &&\n      uiThrowbackFrequency !== throwback_reminder_frequency) ||\n    uiIsDailyReminderEnabled !== reminder_enabled ||\n    (uiIsDailyReminderEnabled &&\n      formatTimeToString(uiDailyReminderTime) !==\n        reminder_time.substring(0, 5));\n\n  // Fetch profile data when the component mounts to ensure it's up-to-date\n  useEffect(() => {\n    fetchProfile(); // Action from profileStore\n  }, [fetchProfile]);\n\n  const handleSave = async () => {\n    setIsSaving(true);\n    try {\n      const throwbackChanged =\n        uiIsThrowbackEnabled !== throwback_reminder_enabled ||\n        (uiIsThrowbackEnabled &&\n          uiThrowbackFrequency !== throwback_reminder_frequency);\n      const dailyReminderChanged =\n        uiIsDailyReminderEnabled !== reminder_enabled ||\n        (uiIsDailyReminderEnabled &&\n          formatTimeToString(uiDailyReminderTime) !==\n            reminder_time.substring(0, 5));\n\n      if (throwbackChanged) {\n        await updateThrowbackPreferences({\n          throwback_reminder_enabled: uiIsThrowbackEnabled,\n          throwback_reminder_frequency: uiIsThrowbackEnabled\n            ? uiThrowbackFrequency\n            : throwback_reminder_frequency, // Persist old frequency if disabled\n        });\n        // Check profileError from the store after the attempt\n        // For immediate feedback, we can rely on the fact that updateThrowbackPreferences handles errors internally.\n        // If no error is set in the store by the action, assume success.\n        // A more robust way would be for updateThrowbackPreferences to return a success/failure boolean or throw.\n        // For now, the alert is kept.\n\n        // Log event for throwback preference change\n        analyticsService.logEvent('throwback_frequency_changed', {\n          enabled: uiIsThrowbackEnabled,\n          frequency: uiIsThrowbackEnabled ? uiThrowbackFrequency : 'off',\n        });\n      }\n\n      if (dailyReminderChanged) {\n        const dailyTimeStr = formatTimeToString(uiDailyReminderTime) + ':00'; // Add seconds for consistency if needed by API\n        await updateDailyReminderSettings({\n          reminder_enabled: uiIsDailyReminderEnabled,\n          reminder_time: dailyTimeStr,\n        });\n        analyticsService.logEvent('reminder_settings_changed', {\n          enabled: uiIsDailyReminderEnabled,\n          time: uiIsDailyReminderEnabled\n            ? formatTimeToString(uiDailyReminderTime)\n            : 'off',\n        });\n      }\n\n      if (throwbackChanged || dailyReminderChanged) {\n        Alert.alert('Başarılı', 'Ayarlar kaydedildi.');\n      } else {\n        // This case should ideally not be hit if button is disabled when !hasChanges\n        Alert.alert('Bilgi', 'Değişiklik yapılmadı.');\n      }\n    } catch (e: any) {\n      // This catch block might not be reached if updateThrowbackPreferences handles its own errors\n      // and updates profileError in the store.\n      Alert.alert(\n        'Hata',\n        e.message || 'Ayarlar kaydedilirken bir hata oluştu.'\n      );\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  const getCurrentFrequencyLabel = () => {\n    return (\n      frequencyOptions.find(opt => opt.value === uiThrowbackFrequency)?.label ||\n      uiThrowbackFrequency\n    );\n  };\n\n  // Show loading indicator if the profile is being fetched and it's not a save operation\n  if (profileLoading && !isSaving) {\n    return (\n      <View style={styles.centered}>\n        <ActivityIndicator size=\"large\" color={theme.colors.primary} />\n      </View>\n    );\n  }\n\n  const handleSignOut = () => {\n    Alert.alert(\n      'Çıkış Yap',\n      'Çıkış yapmak istediğinizden emin misiniz?',\n      [\n        {\n          text: 'İptal',\n          style: 'cancel',\n        },\n        {\n          text: 'Çıkış Yap',\n          style: 'destructive',\n          onPress: async () => {\n            analyticsService.logEvent('user_signed_out');\n            await authLogout();\n            resetProfile();\n            resetThrowback();\n            // Navigation to Auth flow will be handled by RootNavigator due to auth state change\n          },\n        },\n      ],\n      { cancelable: false }\n    );\n  };\n\n  return (\n    <ScrollView\n      style={styles.container}\n      contentContainerStyle={styles.scrollContentContainer}\n    >\n      <Text style={styles.title}>Ayarlar</Text>\n\n      {/* Theme Toggle Section */}\n      <View style={styles.section}>\n        <Text style={styles.sectionTitle}>Görünüm</Text>\n        <View style={styles.settingRow}>\n          <Text style={styles.settingLabel}>Koyu Mod</Text>\n          <Switch\n            isOn={theme.name === 'dark'}\n            onColor={theme.colors.primary}\n            offColor={theme.colors.border}\n            size=\"medium\"\n            onToggle={toggleTheme}\n          />\n        </View>\n      </View>\n\n      {/* Throwback Settings Section */}\n      <View style={styles.section}>\n        <Text style={styles.sectionTitle}>Anı Pırıltısı Ayarları</Text>\n        <View style={styles.settingRow}>\n          <Text style={styles.settingLabel}>Anı Pırıltılarını Etkinleştir</Text>\n          <Switch\n            isOn={uiIsThrowbackEnabled}\n            onColor={theme.colors.primary}\n            offColor={theme.colors.border}\n            size=\"medium\"\n            onToggle={setUiIsThrowbackEnabled}\n          />\n        </View>\n        {uiIsThrowbackEnabled && (\n          <View style={styles.settingRow}>\n            <Text style={styles.settingLabel}>Sıklık</Text>\n            <View style={styles.pickerContainer}>\n              <Picker\n                selectedValue={uiThrowbackFrequency}\n                style={styles.picker}\n                onValueChange={itemValue => setUiThrowbackFrequency(itemValue)}\n                dropdownIconColor={theme.colors.primary}\n              >\n                {frequencyOptions.map(opt => (\n                  <Picker.Item\n                    key={opt.value}\n                    label={opt.label}\n                    value={opt.value}\n                    color={theme.colors.text}\n                  />\n                ))}\n              </Picker>\n            </View>\n          </View>\n        )}\n      </View>\n\n      {/* Account Actions Section */}\n      <View style={styles.section}>\n        <Text style={styles.sectionTitle}>Hesap</Text>\n        <ThemedButton\n          title=\"Çıkış Yap\"\n          onPress={handleSignOut}\n          variant=\"danger\"\n        />\n      </View>\n\n      {/* Daily Reminder Settings Section */}\n      <View style={styles.section}>\n        <Text style={styles.sectionTitle}>Günlük Hatırlatıcı Ayarları</Text>\n        <View style={styles.settingRow}>\n          <Text style={styles.settingLabel}>\n            Günlük Hatırlatıcıyı Etkinleştir\n          </Text>\n          <Switch\n            isOn={uiIsDailyReminderEnabled}\n            onColor={theme.colors.primary}\n            offColor={theme.colors.border}\n            size=\"medium\"\n            onToggle={setUiIsDailyReminderEnabled}\n          />\n        </View>\n        {uiIsDailyReminderEnabled && (\n          <View style={styles.settingRow}>\n            <Text style={styles.settingLabel}>Hatırlatma Saati</Text>\n            <TouchableOpacity\n              onPress={() => setShowDailyTimePicker(true)}\n              style={styles.timeDisplay}\n              activeOpacity={0.7}\n            >\n              <Text style={styles.timeText}>\n                {uiDailyReminderTime.toLocaleTimeString('tr-TR', {\n                  hour: '2-digit',\n                  minute: '2-digit',\n                })}\n              </Text>\n            </TouchableOpacity>\n          </View>\n        )}\n        {showDailyTimePicker && (\n          <DateTimePicker\n            value={uiDailyReminderTime}\n            mode=\"time\"\n            is24Hour={true}\n            display={Platform.OS === 'ios' ? 'spinner' : 'default'}\n            onChange={onDailyTimeChange}\n            textColor={Platform.OS === 'ios' ? theme.colors.text : undefined}\n            style={\n              Platform.OS === 'ios'\n                ? { backgroundColor: theme.colors.background }\n                : {}\n            }\n          />\n        )}\n      </View>\n\n      {/* Legal and Help Section */}\n      <View style={styles.section}>\n        <Text style={styles.sectionTitle}>Yasal Bilgiler ve Destek</Text>\n        <TouchableOpacity\n          style={styles.linkItem}\n          onPress={() =>\n            navigation\n              .getParent<StackNavigationProp<RootStackParamList>>()\n              .navigate('PrivacyPolicy')\n          }\n          activeOpacity={0.7}\n        >\n          <Text style={styles.linkLabel}>Gizlilik Politikası</Text>\n          <Ionicons\n            name=\"chevron-forward-outline\"\n            size={22}\n            color={theme.colors.textSecondary}\n          />\n        </TouchableOpacity>\n        <TouchableOpacity\n          style={styles.linkItem}\n          onPress={() =>\n            navigation\n              .getParent<StackNavigationProp<RootStackParamList>>()\n              .navigate('TermsOfService')\n          }\n          activeOpacity={0.7}\n        >\n          <Text style={styles.linkLabel}>Kullanım Koşulları</Text>\n          <Ionicons\n            name=\"chevron-forward-outline\"\n            size={22}\n            color={theme.colors.textSecondary}\n          />\n        </TouchableOpacity>\n        <TouchableOpacity\n          style={styles.linkItem}\n          onPress={() =>\n            navigation\n              .getParent<StackNavigationProp<RootStackParamList>>()\n              .navigate('Help')\n          }\n          activeOpacity={0.7}\n        >\n          <Text style={styles.linkLabel}>Yardım ve SSS</Text>\n          <Ionicons\n            name=\"chevron-forward-outline\"\n            size={22}\n            color={theme.colors.textSecondary}\n          />\n        </TouchableOpacity>\n      </View>\n\n      {/* Display error from the profile store if any */}\n      {profileError && !isSaving && (\n        <Text style={styles.errorText}>{profileError}</Text>\n      )}\n\n      <ThemedButton\n        title=\"Kaydet\"\n        onPress={handleSave}\n        disabled={!hasChanges || isSaving || profileLoading}\n        isLoading={isSaving}\n        variant=\"primary\"\n        style={styles.saveButtonContainer}\n      />\n    </ScrollView>\n  );\n};\n\nconst createStyles = (theme: ReturnType<typeof useTheme>['theme']) =>\n  StyleSheet.create({\n    centered: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n      backgroundColor: theme.colors.background,\n    },\n    container: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n    },\n    scrollContentContainer: {\n      paddingBottom: theme.spacing.large * 2,\n      paddingHorizontal: theme.spacing.medium,\n    },\n    title: {\n      ...theme.typography.h1,\n      color: theme.colors.text,\n      marginBottom: theme.spacing.large,\n      textAlign: 'center',\n    },\n    section: {\n      marginBottom: theme.spacing.large,\n    },\n    sectionTitle: {\n      ...theme.typography.h2,\n      color: theme.colors.text,\n      marginBottom: theme.spacing.medium,\n    },\n    settingRow: {\n      flexDirection: 'row',\n      justifyContent: 'space-between',\n      alignItems: 'center',\n      paddingVertical: theme.spacing.medium,\n      borderBottomWidth: 1,\n      borderBottomColor: theme.colors.border,\n    },\n    settingLabel: {\n      ...theme.typography.body1,\n      color: theme.colors.text,\n      flex: 1,\n    },\n    frequencyText: {\n      ...theme.typography.body1,\n    },\n    timeDisplay: {\n      paddingVertical: theme.spacing.small,\n      paddingHorizontal: theme.spacing.medium,\n      borderRadius: theme.borderRadius.small,\n      borderWidth: 1,\n      borderColor: theme.colors.border,\n    },\n    timeText: {\n      ...theme.typography.body1,\n      color: theme.colors.primary,\n    },\n    pickerContainer: {\n      flex: 1,\n      marginLeft: theme.spacing.medium,\n    },\n    picker: {\n      height: 50,\n      width: '100%',\n      color: theme.colors.text,\n    },\n    linkLabel: {\n      ...theme.typography.body1,\n      color: theme.colors.text,\n    },\n    errorText: {\n      ...theme.typography.caption,\n      color: theme.colors.error,\n      textAlign: 'center',\n      marginTop: theme.spacing.medium,\n    },\n    linkItem: {\n      flexDirection: 'row',\n      justifyContent: 'space-between',\n      alignItems: 'center',\n      paddingVertical: theme.spacing.medium,\n      borderBottomWidth: 1,\n      borderBottomColor: theme.colors.border,\n    },\n    saveButtonContainer: {\n      marginTop: theme.spacing.large,\n    },\n  });\n\nexport default SettingsScreen;\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/screens/SignUpScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/screens/SplashScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/screens/TermsOfServiceScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/screens/onboarding/OnboardingReminderSetupScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'navigation' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":40,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":40,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":120,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4022,4025],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4022,4025],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":153,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5116,5119],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5116,5119],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Ionicons } from '@expo/vector-icons';\nimport DateTimePicker, {\n  DateTimePickerEvent,\n} from '@react-native-community/datetimepicker';\nimport { useNavigation } from '@react-navigation/native';\nimport { NativeStackNavigationProp } from '@react-navigation/native-stack';\nimport React, { useEffect, useState } from 'react';\nimport {\n  Alert,\n  Platform,\n  StyleSheet,\n  Text,\n  TouchableOpacity,\n  View,\n} from 'react-native';\nimport ToggleSwitch from 'toggle-switch-react-native';\n\nimport type { ProfileResponse } from '../../api/profileApi'; // Import type separately\nimport * as profileApi from '../../api/profileApi';\nimport ThemedButton from '../../components/ThemedButton';\nimport { useTheme } from '../../providers/ThemeProvider';\nimport { analyticsService } from '../../services/analyticsService';\nimport {\n  cancelAllScheduledNotifications,\n  requestNotificationPermissions,\n  scheduleDailyReminder,\n} from '../../services/notificationService';\nimport { type ProfileState, useProfileStore } from '../../store/profileStore';\nimport { AppTheme } from '../../themes/types';\nimport { RootStackParamList } from '../../types/navigation';\n\ntype OnboardingReminderSetupNavigationProp = NativeStackNavigationProp<\n  RootStackParamList,\n  'OnboardingReminderSetup'\n>;\n\nconst OnboardingReminderSetupScreen: React.FC = () => {\n  const { theme } = useTheme();\n  const styles = createStyles(theme);\n  const navigation = useNavigation<OnboardingReminderSetupNavigationProp>();\n  const { id, reminder_enabled, reminder_time, setProfile, setLoading } =\n    useProfileStore();\n\n  const [localReminderEnabled, setLocalReminderEnabled] = useState(\n    reminder_enabled !== undefined ? reminder_enabled : true\n  );\n  const [localReminderTime, setLocalReminderTime] = useState(\n    reminder_time\n      ? new Date(`1970-01-01T${reminder_time}`)\n      : new Date(new Date().setHours(20, 0, 0, 0))\n  );\n  const [showTimePicker, setShowTimePicker] = useState(false);\n  const [isSaving, setIsSaving] = useState(false);\n  const [isSkipping, setIsSkipping] = useState(false);\n\n  useEffect(() => {\n    setLocalReminderEnabled(\n      reminder_enabled !== undefined ? reminder_enabled : true\n    );\n    setLocalReminderTime(\n      reminder_time\n        ? new Date(`1970-01-01T${reminder_time}`)\n        : new Date(new Date().setHours(20, 0, 0, 0))\n    );\n  }, [reminder_enabled, reminder_time]);\n\n  const handleTimeChange = (\n    event: DateTimePickerEvent,\n    selectedDate?: Date\n  ) => {\n    setShowTimePicker(Platform.OS === 'ios');\n    if (selectedDate) {\n      setLocalReminderTime(selectedDate);\n    }\n  };\n\n  const handleSaveSettings = async () => {\n    if (!id) {\n      Alert.alert('Hata', 'Kullanıcı kimliği bulunamadı.', [{ text: 'Tamam' }]);\n      return;\n    }\n    setIsSaving(true);\n    setLoading(true);\n\n    const timeString = localReminderTime\n      .toTimeString()\n      .split(' ')[0]\n      .substring(0, 5);\n\n    try {\n      const profileUpdateData: Partial<ProfileResponse> = {\n        onboarded: true,\n        reminder_enabled: localReminderEnabled,\n        reminder_time: timeString,\n      };\n      if (localReminderEnabled) {\n        const permissionGranted = await requestNotificationPermissions();\n        if (permissionGranted) {\n          const hour = localReminderTime.getHours();\n          const minute = localReminderTime.getMinutes();\n          await scheduleDailyReminder(\n            hour,\n            minute,\n            'Günlük Minnettarlık Zamanı',\n            'Bugün neleri fark ettin? Yazmaya ne dersin?'\n          );\n        } else {\n          profileUpdateData.reminder_enabled = false;\n        }\n      } else {\n        await cancelAllScheduledNotifications();\n      }\n\n      await profileApi.updateProfile(profileUpdateData);\n      setProfile(profileUpdateData as Partial<ProfileState>);\n      analyticsService.logEvent('onboarding_completed', {\n        reminders_skipped: false,\n      });\n      // Navigation to MainApp is now handled by RootNavigator's conditional rendering\n    } catch (error: any) {\n      console.error('Onboarding tamamlama hatası (hatırlatıcı):', error);\n      Alert.alert(\n        'Hata',\n        (error as Error).message || 'Onboarding tamamlanamadı.',\n        [{ text: 'Tamam', style: 'default' }]\n      );\n    } finally {\n      setIsSaving(false);\n      setLoading(false);\n    }\n  };\n\n  const handleSkip = async () => {\n    if (!id) {\n      Alert.alert('Hata', 'Kullanıcı kimliği bulunamadı.', [{ text: 'Tamam' }]);\n      return;\n    }\n    setIsSkipping(true);\n    setLoading(true);\n    try {\n      const profileUpdateData: Partial<ProfileResponse> = {\n        onboarded: true,\n        reminder_enabled: false,\n      };\n      await profileApi.updateProfile(profileUpdateData);\n      setProfile(profileUpdateData as Partial<ProfileState>);\n      await cancelAllScheduledNotifications();\n      analyticsService.logEvent('onboarding_reminder_setup_skipped');\n      analyticsService.logEvent('onboarding_completed', {\n        reminders_skipped: true,\n      });\n      // Navigation to MainApp is now handled by RootNavigator's conditional rendering\n    } catch (error: any) {\n      console.error('Onboarding skip error:', error);\n      Alert.alert(\n        'Hata',\n        (error as Error).message || 'Onboarding atlanamadı.',\n        [{ text: 'Tamam', style: 'default' }]\n      );\n    } finally {\n      setIsSkipping(false);\n      setLoading(false);\n    }\n  };\n\n  return (\n    <View style={styles.container}>\n      <Ionicons\n        name=\"notifications-outline\"\n        size={48}\n        color={theme.colors.primary}\n        style={styles.icon}\n      />\n      <Text style={styles.title}>Günlük Hatırlatıcı</Text>\n      <Text style={styles.description}>\n        Harika! Yeşer'i keşfetmeye hazırsın. Minnettarlık pratiğini sürdürmene\n        yardımcı olmak için şimdi günlük bir hatırlatıcı ayarlayabilirsin.\n      </Text>\n\n      <View style={styles.settingRow}>\n        <Text style={styles.settingLabel}>Hatırlatıcıları Etkinleştir</Text>\n        <ToggleSwitch\n          isOn={localReminderEnabled}\n          onColor={theme.colors.primary}\n          offColor={theme.colors.border}\n          thumbOnStyle={{ backgroundColor: theme.colors.onPrimary }}\n          thumbOffStyle={{ backgroundColor: theme.colors.surface }}\n          size=\"medium\"\n          onToggle={(isOn: boolean) => setLocalReminderEnabled(isOn)}\n        />\n      </View>\n\n      {localReminderEnabled && (\n        <View style={styles.timePickerRow}>\n          <Text style={styles.settingLabel}>Hatırlatma Saati:</Text>\n          <TouchableOpacity\n            onPress={() => setShowTimePicker(true)}\n            style={styles.timeDisplay}\n            activeOpacity={0.7}\n          >\n            <Text style={styles.timeText}>\n              {localReminderTime.toLocaleTimeString('tr-TR', {\n                hour: '2-digit',\n                minute: '2-digit',\n              })}\n            </Text>\n          </TouchableOpacity>\n        </View>\n      )}\n\n      {showTimePicker && (\n        <DateTimePicker\n          value={localReminderTime}\n          mode=\"time\"\n          is24Hour={true}\n          display=\"spinner\"\n          onChange={handleTimeChange}\n        />\n      )}\n\n      <ThemedButton\n        title={isSaving ? 'Kaydediliyor...' : 'Kaydet ve Bitir'}\n        onPress={handleSaveSettings}\n        disabled={isSaving || isSkipping}\n        variant=\"primary\"\n        style={styles.button}\n      />\n\n      <ThemedButton\n        title={isSkipping ? 'Atlanıyor...' : 'Şimdilik Atla'}\n        onPress={handleSkip}\n        disabled={isSaving || isSkipping}\n        variant=\"secondary\"\n        style={styles.skipButton}\n      />\n    </View>\n  );\n};\n\nconst createStyles = (theme: AppTheme) =>\n  StyleSheet.create({\n    container: {\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n      padding: theme.spacing.large,\n      backgroundColor: theme.colors.background,\n    },\n    icon: {\n      marginBottom: theme.spacing.medium,\n    },\n    title: {\n      ...theme.typography.h2,\n      color: theme.colors.primary,\n      textAlign: 'center',\n      marginBottom: theme.spacing.medium,\n    },\n    description: {\n      ...theme.typography.body1,\n      color: theme.colors.textSecondary,\n      textAlign: 'center',\n      marginBottom: theme.spacing.large,\n      lineHeight: theme.typography.body1.lineHeight\n        ? theme.typography.body1.lineHeight * 1.5\n        : 24,\n    },\n    settingRow: {\n      flexDirection: 'row',\n      justifyContent: 'space-between',\n      alignItems: 'center',\n      width: '100%',\n      paddingVertical: theme.spacing.medium,\n      paddingHorizontal: theme.spacing.medium,\n      backgroundColor: theme.colors.surface,\n      borderRadius: theme.borderRadius.medium,\n      marginBottom: theme.spacing.large,\n      elevation: 1,\n      shadowColor: theme.colors.shadow,\n      shadowOffset: { width: 0, height: 1 },\n      shadowOpacity: 0.2,\n      shadowRadius: 1.5,\n    },\n    settingLabel: {\n      ...theme.typography.body1,\n      color: theme.colors.text,\n      fontWeight: '500',\n    },\n    timePickerRow: {\n      flexDirection: 'row',\n      justifyContent: 'space-between',\n      alignItems: 'center',\n      width: '100%',\n      paddingVertical: theme.spacing.medium,\n      paddingHorizontal: theme.spacing.medium,\n      backgroundColor: theme.colors.surface,\n      borderRadius: theme.borderRadius.medium,\n      marginBottom: theme.spacing.large,\n      elevation: 1,\n      shadowColor: theme.colors.shadow,\n      shadowOffset: { width: 0, height: 1 },\n      shadowOpacity: 0.2,\n      shadowRadius: 1.5,\n    },\n    timeDisplay: {\n      paddingVertical: theme.spacing.small,\n      paddingHorizontal: theme.spacing.medium,\n      backgroundColor: theme.colors.inputBackground,\n      borderRadius: theme.borderRadius.small,\n    },\n    timeText: {\n      ...theme.typography.body1,\n      color: theme.colors.primary,\n      fontWeight: '500',\n    },\n    button: {\n      marginTop: theme.spacing.medium,\n      width: '90%',\n      alignSelf: 'center',\n    },\n    skipButton: {\n      marginTop: theme.spacing.medium,\n      width: '90%',\n      alignSelf: 'center',\n    },\n  });\n\nexport default OnboardingReminderSetupScreen;\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/screens/onboarding/OnboardingScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TouchableOpacity' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1740,1743],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1740,1743],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useNavigation } from '@react-navigation/native';\nimport { NativeStackNavigationProp } from '@react-navigation/native-stack';\nimport React, { useRef, useState } from 'react';\nimport {\n  Dimensions,\n  FlatList,\n  StyleSheet,\n  Text,\n  TouchableOpacity,\n  View,\n} from 'react-native';\n\nimport ThemedButton from '../../components/ThemedButton';\nimport { useTheme } from '../../providers/ThemeProvider';\nimport { AppTheme } from '../../themes/types';\nimport { RootStackParamList } from '../../types/navigation';\n\ntype OnboardingScreenNavigationProp = NativeStackNavigationProp<\n  RootStackParamList,\n  'Onboarding'\n>;\n\nconst { width: screenWidth } = Dimensions.get('window');\n\nconst onboardingSlides = [\n  {\n    key: '1',\n    title: \"Yeşer'e Hoş Geldin!\",\n    description:\n      'Minnettarlık günlüğü tutmak, pozitifliği artırmanın ve genel refahını iyileştirmenin harika bir yoludur. Her gün birkaç dakikanı ayırarak hayatındaki güzel şeylere odaklan.',\n  },\n  {\n    key: '2',\n    title: '✨ Anı Pırıltıları ✨',\n    description:\n      'Geçmişteki güzel anılarını yeniden keşfet! Yeşer, sana zaman zaman eski kayıtlarını hatırlatarak o günkü minnettarlığını tekrar yaşamanı sağlar.',\n    privacyNote: 'Günlüğün sana özeldir. Gizliliğine önem veriyoruz.',\n    showButton: true,\n  },\n];\n\nconst OnboardingScreen: React.FC = () => {\n  const navigation = useNavigation<OnboardingScreenNavigationProp>();\n  const { theme } = useTheme();\n  const styles = createStyles(theme);\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const flatListRef = useRef<FlatList>(null);\n\n  const handleContinueToReminderSetup = () => {\n    navigation.navigate('OnboardingReminderSetup');\n  };\n\n  const onViewableItemsChanged = useRef(({ viewableItems }: any) => {\n    if (viewableItems.length > 0) {\n      setCurrentIndex(viewableItems[0].index);\n    }\n  }).current;\n\n  const viewabilityConfig = useRef({ itemVisiblePercentThreshold: 50 }).current;\n\n  const renderItem = ({ item }: { item: (typeof onboardingSlides)[0] }) => (\n    <View style={styles.slide}>\n      <Text style={styles.title}>{item.title}</Text>\n      <Text style={styles.description}>{item.description}</Text>\n      {item.privacyNote && (\n        <Text style={styles.privacyNote}>{item.privacyNote}</Text>\n      )}\n      {item.showButton && (\n        <ThemedButton\n          title=\"Hadi Başlayalım!\"\n          onPress={handleContinueToReminderSetup}\n          variant=\"primary\"\n          style={styles.button}\n        />\n      )}\n    </View>\n  );\n\n  return (\n    <View style={styles.container}>\n      <FlatList\n        ref={flatListRef}\n        data={onboardingSlides}\n        renderItem={renderItem}\n        horizontal\n        pagingEnabled\n        showsHorizontalScrollIndicator={false}\n        keyExtractor={item => item.key}\n        onViewableItemsChanged={onViewableItemsChanged}\n        viewabilityConfig={viewabilityConfig}\n        style={{ flex: 1 }}\n      />\n      <View style={styles.paginationContainer}>\n        {onboardingSlides.map((_, index) => (\n          <View\n            key={index}\n            style={[\n              styles.paginationDot,\n              currentIndex === index\n                ? styles.paginationDotActive\n                : styles.paginationDotInactive,\n            ]}\n          />\n        ))}\n      </View>\n    </View>\n  );\n};\n\nconst createStyles = (theme: AppTheme) =>\n  StyleSheet.create({\n    container: {\n      flex: 1,\n      backgroundColor: theme.colors.background,\n    },\n    slide: {\n      width: screenWidth,\n      flex: 1,\n      justifyContent: 'center',\n      alignItems: 'center',\n      paddingHorizontal: theme.spacing.large * 2, // More horizontal padding for slide content\n      paddingBottom: 100, // Space for pagination and to push content up a bit\n    },\n    title: {\n      ...theme.typography.h1,\n      color: theme.colors.primary,\n      textAlign: 'center',\n      marginBottom: theme.spacing.large,\n    },\n    description: {\n      ...theme.typography.body1,\n      color: theme.colors.textSecondary,\n      textAlign: 'center',\n      marginBottom: theme.spacing.xl,\n      lineHeight: theme.typography.body1.lineHeight\n        ? theme.typography.body1.lineHeight * 1.5\n        : 24,\n    },\n    privacyNote: {\n      ...theme.typography.caption,\n      color: theme.colors.textSecondary, // Changed from textTertiary\n      textAlign: 'center',\n      marginTop: theme.spacing.medium,\n      marginBottom: theme.spacing.large,\n    },\n    button: {\n      marginTop: theme.spacing.large,\n      width: '80%',\n      alignSelf: 'center',\n    },\n    paginationContainer: {\n      position: 'absolute',\n      bottom: theme.spacing.xl, // Position at the bottom\n      left: 0,\n      right: 0,\n      flexDirection: 'row',\n      justifyContent: 'center',\n      alignItems: 'center',\n    },\n    paginationDot: {\n      width: 8,\n      height: 8,\n      borderRadius: 4,\n      marginHorizontal: theme.spacing.xs, // Changed from tiny\n    },\n    paginationDotActive: {\n      backgroundColor: theme.colors.primary,\n    },\n    paginationDotInactive: {\n      backgroundColor: theme.colors.border,\n    },\n  });\n\nexport default OnboardingScreen;\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/services/analyticsService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[933,936],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[933,936],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getAnalytics } from '@react-native-firebase/analytics';\n\nconst analytics = getAnalytics();\n\n/**\n * Logs a screen view event to Firebase Analytics.\n * Screen names should be clear and descriptive.\n * @param screenName The name of the screen to track.\n */\nconst logScreenView = async (screenName: string): Promise<void> => {\n  try {\n    await analytics.logScreenView({\n      screen_name: screenName,\n      screen_class: screenName, // Often same as screen_name for RN apps\n    });\n    // console.log(`Analytics: Screen view logged - ${screenName}`);\n  } catch (error) {\n    console.error('Failed to log screen view to Firebase Analytics', error);\n  }\n};\n\n/**\n * Logs a custom event to Firebase Analytics.\n * @param eventName The name of the event (e.g., 'button_click', 'item_shared').\n * @param params Optional parameters associated with the event.\n */\nconst logEvent = async (\n  eventName: string,\n  params?: Record<string, any>\n): Promise<void> => {\n  try {\n    await analytics.logEvent(eventName, params);\n    // console.log(`Analytics: Event logged - ${eventName}`, params || '');\n  } catch (error) {\n    console.error(\n      `Failed to log event '${eventName}' to Firebase Analytics`,\n      error\n    );\n  }\n};\n\n/**\n * Logs an 'app_open' event.\n * This can be called when the application is first initialized.\n */\nconst logAppOpen = async (): Promise<void> => {\n  try {\n    await analytics.logAppOpen();\n    // console.log('Analytics: App open event logged');\n  } catch (error) {\n    console.error('Failed to log app_open event to Firebase Analytics', error);\n  }\n};\n\nexport const analyticsService = {\n  logScreenView,\n  logEvent,\n  logAppOpen,\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/services/authService.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mockSupabaseSignIn' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":33,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":33,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'subscription' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":442,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":442,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/services/authService.test.ts\nimport { AuthError, Session, User } from '@supabase/supabase-js';\n\nimport { supabase } from '../utils/supabaseClient';\nimport {\n  EmailPasswordCredentials,\n  getCurrentSession,\n  getCurrentUser,\n  onAuthStateChange,\n  signInWithEmail,\n  signInWithGoogle,\n  signOut,\n  signUpWithEmail,\n} from './authService';\n\njest.mock('../utils/supabaseClient', () => ({\n  supabase: {\n    auth: {\n      signUp: jest.fn(),\n      signInWithPassword: jest.fn(),\n      signOut: jest.fn(),\n      getUser: jest.fn(),\n      getSession: jest.fn(),\n      onAuthStateChange: jest.fn(),\n      signInWithOAuth: jest.fn(), // Added for Google Sign-In\n      // We will add other methods here as we test them\n    },\n  },\n}));\n\n// Typed mocks\nconst mockSupabaseSignUp = supabase.auth.signUp as jest.Mock;\nconst mockSupabaseSignIn = supabase.auth.signInWithPassword as jest.Mock;\nconst mockSupabaseSignOut = supabase.auth.signOut as jest.Mock;\nconst mockSupabaseGetUser = supabase.auth.getUser as jest.Mock;\nconst mockSupabaseGetSession = supabase.auth.getSession as jest.Mock;\nconst mockSupabaseOnAuthStateChange = supabase.auth\n  .onAuthStateChange as jest.Mock;\nconst mockSupabaseSignInWithOAuth = supabase.auth.signInWithOAuth as jest.Mock;\n\ndescribe('authService - signUpWithEmail', () => {\n  const mockCredentials: EmailPasswordCredentials = {\n    email: 'test@example.com',\n    password: 'password123',\n    options: { data: { full_name: 'Test User' } },\n  };\n\n  beforeEach(() => {\n    // Clear mock history before each test\n    mockSupabaseSignUp.mockClear();\n  });\n\n  it('should return user and session on successful sign up', async () => {\n    const mockUser = { id: 'user-id', email: mockCredentials.email } as User;\n    const mockSession = { access_token: 'token', user: mockUser } as Session;\n\n    mockSupabaseSignUp.mockResolvedValueOnce({\n      data: { user: mockUser, session: mockSession },\n      error: null,\n    });\n\n    const result = await signUpWithEmail(mockCredentials);\n\n    expect(mockSupabaseSignUp).toHaveBeenCalledWith({\n      email: mockCredentials.email,\n      password: mockCredentials.password,\n      options: mockCredentials.options,\n    });\n    expect(result.user).toEqual(mockUser);\n    expect(result.session).toEqual(mockSession);\n    expect(result.error).toBeNull();\n  });\n\n  it('should return an error if sign up fails', async () => {\n    const mockError = {\n      message: 'Sign up failed',\n      name: 'AuthError',\n      status: 400,\n    } as AuthError;\n\n    mockSupabaseSignUp.mockResolvedValueOnce({\n      data: { user: null, session: null },\n      error: mockError,\n    });\n\n    const result = await signUpWithEmail(mockCredentials);\n\n    expect(mockSupabaseSignUp).toHaveBeenCalledWith({\n      email: mockCredentials.email,\n      password: mockCredentials.password,\n      options: mockCredentials.options,\n    });\n    expect(result.user).toBeNull();\n    expect(result.session).toBeNull();\n    expect(result.error).toEqual(mockError);\n  });\n\n  it('should return null user and session if sign up returns no data and no error', async () => {\n    // This tests an unlikely but possible scenario where the API returns no error but also no data.\n    mockSupabaseSignUp.mockResolvedValueOnce({\n      data: { user: null, session: null }, // Or simply data: null\n      error: null,\n    });\n\n    const result = await signUpWithEmail(mockCredentials);\n\n    expect(mockSupabaseSignUp).toHaveBeenCalledWith({\n      email: mockCredentials.email,\n      password: mockCredentials.password,\n      options: mockCredentials.options,\n    });\n    expect(result.user).toBeNull();\n    expect(result.session).toBeNull();\n    expect(result.error).toBeNull(); // Or handle as an implicit error if this state is unexpected\n  });\n\n  it('should handle options correctly when passed', async () => {\n    const mockUser = { id: 'user-id', email: mockCredentials.email } as User;\n    const mockSession = { access_token: 'token', user: mockUser } as Session;\n\n    mockSupabaseSignUp.mockResolvedValueOnce({\n      data: { user: mockUser, session: mockSession },\n      error: null,\n    });\n\n    await signUpWithEmail(mockCredentials); // options are included in mockCredentials\n\n    expect(mockSupabaseSignUp).toHaveBeenCalledWith(\n      expect.objectContaining({\n        options: { data: { full_name: 'Test User' } },\n      })\n    );\n  });\n\n  it('should handle calls without options', async () => {\n    const credentialsWithoutOptions: EmailPasswordCredentials = {\n      email: 'testnooptions@example.com',\n      password: 'password123',\n    };\n    const mockUser = {\n      id: 'user-id-no-options',\n      email: credentialsWithoutOptions.email,\n    } as User;\n    const mockSession = { access_token: 'token', user: mockUser } as Session;\n\n    mockSupabaseSignUp.mockResolvedValueOnce({\n      data: { user: mockUser, session: mockSession },\n      error: null,\n    });\n\n    await signUpWithEmail(credentialsWithoutOptions);\n\n    expect(mockSupabaseSignUp).toHaveBeenCalledWith({\n      email: credentialsWithoutOptions.email,\n      password: credentialsWithoutOptions.password,\n      options: undefined, // Ensure options is undefined if not provided\n    });\n  });\n});\n\ndescribe('authService - signInWithEmail', () => {\n  const mockCredentials: EmailPasswordCredentials = {\n    email: 'test@example.com',\n    password: 'password123',\n  };\n\n  const mockSupabaseSignIn = supabase.auth.signInWithPassword as jest.Mock;\n\n  beforeEach(() => {\n    mockSupabaseSignIn.mockClear();\n  });\n\n  it('should return user and session on successful sign in', async () => {\n    const mockUser = { id: 'user-id', email: mockCredentials.email } as User;\n    const mockSession = { access_token: 'token', user: mockUser } as Session;\n\n    mockSupabaseSignIn.mockResolvedValueOnce({\n      data: { user: mockUser, session: mockSession },\n      error: null,\n    });\n\n    const result = await signInWithEmail(mockCredentials);\n\n    expect(mockSupabaseSignIn).toHaveBeenCalledWith({\n      email: mockCredentials.email,\n      password: mockCredentials.password,\n    });\n    expect(result.user).toEqual(mockUser);\n    expect(result.session).toEqual(mockSession);\n    expect(result.error).toBeNull();\n  });\n\n  it('should return an error if sign in fails', async () => {\n    const mockError = {\n      message: 'Invalid credentials',\n      name: 'AuthApiError',\n      status: 400,\n    } as AuthError;\n\n    mockSupabaseSignIn.mockResolvedValueOnce({\n      data: { user: null, session: null },\n      error: mockError,\n    });\n\n    const result = await signInWithEmail(mockCredentials);\n\n    expect(mockSupabaseSignIn).toHaveBeenCalledWith({\n      email: mockCredentials.email,\n      password: mockCredentials.password,\n    });\n    expect(result.user).toBeNull();\n    expect(result.session).toBeNull();\n    expect(result.error).toEqual(mockError);\n  });\n\n  it('should return null user and session if sign in returns no data and no error', async () => {\n    mockSupabaseSignIn.mockResolvedValueOnce({\n      data: { user: null, session: null },\n      error: null,\n    });\n\n    const result = await signInWithEmail(mockCredentials);\n\n    expect(mockSupabaseSignIn).toHaveBeenCalledWith({\n      email: mockCredentials.email,\n      password: mockCredentials.password,\n    });\n    expect(result.user).toBeNull();\n    expect(result.session).toBeNull();\n    expect(result.error).toBeNull();\n  });\n});\n\ndescribe('authService - signOut', () => {\n  beforeEach(() => {\n    mockSupabaseSignOut.mockClear();\n  });\n\n  it('should return no error on successful sign out', async () => {\n    mockSupabaseSignOut.mockResolvedValueOnce({ error: null });\n\n    const result = await signOut();\n\n    expect(mockSupabaseSignOut).toHaveBeenCalledTimes(1);\n    expect(result.error).toBeNull();\n  });\n\n  it('should return an error if sign out fails', async () => {\n    const mockError = {\n      message: 'Sign out failed',\n      name: 'AuthApiError',\n      status: 500,\n    } as AuthError;\n    mockSupabaseSignOut.mockResolvedValueOnce({ error: mockError });\n\n    const result = await signOut();\n\n    expect(mockSupabaseSignOut).toHaveBeenCalledTimes(1);\n    expect(result.error).toEqual(mockError);\n  });\n});\n\ndescribe('authService - getCurrentUser', () => {\n  beforeEach(() => {\n    mockSupabaseGetUser.mockClear();\n  });\n\n  it('should return a user object if a user is authenticated', async () => {\n    const mockUser = { id: 'user-id', email: 'test@example.com' } as User;\n    mockSupabaseGetUser.mockResolvedValueOnce({\n      data: { user: mockUser },\n      error: null,\n    });\n\n    const result = await getCurrentUser();\n\n    expect(mockSupabaseGetUser).toHaveBeenCalledTimes(1);\n    expect(result.user).toEqual(mockUser);\n    expect(result.error).toBeNull();\n  });\n\n  it('should return null if no user is authenticated', async () => {\n    mockSupabaseGetUser.mockResolvedValueOnce({\n      data: { user: null },\n      error: null,\n    });\n\n    const result = await getCurrentUser();\n\n    expect(mockSupabaseGetUser).toHaveBeenCalledTimes(1);\n    expect(result.user).toBeNull();\n    expect(result.error).toBeNull();\n  });\n\n  it('should return an error if fetching the user fails', async () => {\n    const mockError = {\n      message: 'Failed to fetch user',\n      name: 'AuthApiError',\n      status: 500,\n    } as AuthError;\n    mockSupabaseGetUser.mockResolvedValueOnce({\n      data: { user: null },\n      error: mockError,\n    });\n\n    const result = await getCurrentUser();\n\n    expect(mockSupabaseGetUser).toHaveBeenCalledTimes(1);\n    expect(result.user).toBeNull();\n    expect(result.error).toEqual(mockError);\n  });\n});\n\ndescribe('authService - getCurrentSession', () => {\n  beforeEach(() => {\n    mockSupabaseGetSession.mockClear();\n    jest.spyOn(console, 'error').mockImplementation(() => {}); // Suppress console.error for cleaner test output\n  });\n\n  afterEach(() => {\n    (console.error as jest.Mock).mockRestore();\n  });\n\n  it('should return a session object if a session is active', async () => {\n    const mockUser = { id: 'user-id', email: 'test@example.com' } as User;\n    const mockSession = {\n      access_token: 'active-token',\n      user: mockUser,\n      expires_in: 3600,\n      token_type: 'bearer',\n    } as Session;\n    mockSupabaseGetSession.mockResolvedValueOnce({\n      data: { session: mockSession },\n      error: null,\n    });\n\n    const result = await getCurrentSession();\n\n    expect(mockSupabaseGetSession).toHaveBeenCalledTimes(1);\n    expect(result).toEqual(mockSession);\n  });\n\n  it('should return null if no session is active', async () => {\n    mockSupabaseGetSession.mockResolvedValueOnce({\n      data: { session: null },\n      error: null,\n    });\n\n    const result = await getCurrentSession();\n\n    expect(mockSupabaseGetSession).toHaveBeenCalledTimes(1);\n    expect(result).toBeNull();\n  });\n\n  it('should return null if fetching the session fails', async () => {\n    const mockError = {\n      message: 'Failed to fetch session',\n      name: 'AuthApiError',\n      status: 500,\n    } as AuthError;\n    mockSupabaseGetSession.mockResolvedValueOnce({\n      data: { session: null },\n      error: mockError,\n    });\n\n    const result = await getCurrentSession();\n\n    expect(mockSupabaseGetSession).toHaveBeenCalledTimes(1);\n    expect(result).toBeNull();\n    expect(console.error).toHaveBeenCalledWith(\n      'Error getting session:',\n      mockError.message\n    );\n  });\n});\n\ndescribe('authService - onAuthStateChange', () => {\n  let mockUserCallback: (event: string, session: Session | null) => void;\n  const mockUnsubscribe = jest.fn();\n\n  beforeEach(() => {\n    mockSupabaseOnAuthStateChange.mockClear(); // Reset call count before each test\n    mockSupabaseOnAuthStateChange.mockImplementation(callback => {\n      // Capture the callback provided by the SUT (System Under Test)\n      mockUserCallback = callback;\n      // Return the structure expected by the SUT\n      return { data: { subscription: { unsubscribe: mockUnsubscribe } } };\n    });\n    // Ensure mockUserCallback is a Jest mock function if we want to check its calls directly\n    // For this setup, we are capturing the SUT's callback into mockUserCallback and then calling it.\n    // If testCallback is the one we want to check, that's fine.\n    mockUnsubscribe.mockClear();\n  });\n\n  it('should register the callback and trigger it on SIGNED_IN event', () => {\n    const testCallback = jest.fn();\n    onAuthStateChange(testCallback);\n\n    expect(mockSupabaseOnAuthStateChange).toHaveBeenCalledTimes(1);\n\n    // Simulate Supabase triggering the callback for a SIGNED_IN event\n    const mockUser = { id: 'user-id', email: 'test@example.com' } as User;\n    const mockSession = {\n      access_token: 'active-token',\n      user: mockUser,\n    } as Session;\n    // Manually invoke the captured callback\n    if (mockUserCallback) mockUserCallback('SIGNED_IN', mockSession);\n\n    expect(testCallback).toHaveBeenCalledWith('SIGNED_IN', mockSession);\n  });\n\n  it('should register the callback and trigger it on SIGNED_OUT event', () => {\n    const testCallback = jest.fn();\n    onAuthStateChange(testCallback);\n\n    expect(mockSupabaseOnAuthStateChange).toHaveBeenCalledTimes(1);\n\n    // Simulate Supabase triggering the callback for a SIGNED_OUT event\n    if (mockUserCallback) mockUserCallback('SIGNED_OUT', null);\n\n    expect(testCallback).toHaveBeenCalledWith('SIGNED_OUT', null);\n  });\n\n  it('should return a subscription object with an unsubscribe method', () => {\n    const testCallback = jest.fn();\n    const subscription = onAuthStateChange(testCallback);\n\n    expect(subscription).toBeDefined();\n    expect(subscription?.unsubscribe).toBeDefined();\n    expect(typeof subscription?.unsubscribe).toBe('function');\n\n    // Call unsubscribe\n    subscription?.unsubscribe();\n    expect(mockUnsubscribe).toHaveBeenCalledTimes(1);\n  });\n\n  it('should handle null being returned for subscription data (edge case)', () => {\n    // Simulate Supabase returning null for the subscription data part\n    mockSupabaseOnAuthStateChange.mockReturnValueOnce({ data: null });\n    const testCallback = jest.fn();\n    const subscription = onAuthStateChange(testCallback);\n  });\n\n  it('should register the callback and trigger it on SIGNED_IN event', () => {\n    const testCallback = jest.fn();\n    onAuthStateChange(testCallback);\n\n    expect(mockSupabaseOnAuthStateChange).toHaveBeenCalledTimes(1);\n\n    // Simulate Supabase triggering the callback for a SIGNED_IN event\n    const mockUser = { id: 'user-id', email: 'test@example.com' } as User;\n    const mockSession = {\n      access_token: 'active-token',\n      user: mockUser,\n    } as Session;\n    // Manually invoke the captured callback\n    if (mockUserCallback) mockUserCallback('SIGNED_IN', mockSession);\n\n    expect(testCallback).toHaveBeenCalledWith('SIGNED_IN', mockSession);\n  });\n\n  it('should register the callback and trigger it on SIGNED_OUT event', () => {\n    const testCallback = jest.fn();\n    onAuthStateChange(testCallback);\n\n    expect(mockSupabaseOnAuthStateChange).toHaveBeenCalledTimes(1);\n\n    // Simulate Supabase triggering the callback for a SIGNED_OUT event\n    if (mockUserCallback) mockUserCallback('SIGNED_OUT', null);\n\n    expect(testCallback).toHaveBeenCalledWith('SIGNED_OUT', null);\n  });\n\n  it('should return a subscription object with an unsubscribe method', () => {\n    const mockUnsubscribe = jest.fn();\n    // Simulate Supabase returning a subscription object\n    mockSupabaseOnAuthStateChange.mockReturnValueOnce({\n      data: { subscription: { unsubscribe: mockUnsubscribe } },\n    });\n\n    const testCallback = jest.fn();\n    const subscriptionData = onAuthStateChange(testCallback);\n    // The actual subscription object is nested within the returned 'data' property from supabase.auth.onAuthStateChange\n    // and our service function returns this 'data.subscription'\n    const subscription = subscriptionData; // In our service, we return data.subscription directly\n\n    expect(subscription).toBeDefined();\n    if (subscription) {\n      expect(subscription.unsubscribe).toBeDefined();\n      expect(typeof subscription.unsubscribe).toBe('function');\n      // Call unsubscribe to ensure the mock is called if it's part of the returned object\n      subscription.unsubscribe();\n      expect(mockUnsubscribe).toHaveBeenCalledTimes(1);\n    } else {\n      // This case should ideally not be hit if Supabase behaves as expected\n      // and our mock is set up correctly for this test.\n      throw new Error(\n        'Subscription was not defined, check mock setup for onAuthStateChange.'\n      );\n    }\n  });\n});\n\ndescribe('authService - signInWithGoogle', () => {\n  let consoleWarnSpy: jest.SpyInstance;\n  let consoleErrorSpy: jest.SpyInstance;\n\n  beforeEach(() => {\n    mockSupabaseSignInWithOAuth.mockClear();\n    // Suppress console.warn and console.error for cleaner test output, but allow checking calls\n    consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});\n    consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(() => {});\n  });\n\n  afterEach(() => {\n    consoleWarnSpy.mockRestore();\n    consoleErrorSpy.mockRestore();\n  });\n\n  it('should return FeatureDisabledError if supabase.auth.signInWithOAuth provides a URL (WebBrowser part is disabled)', async () => {\n    const mockOAuthUrl =\n      'https://supabase.io/auth/v1/authorize?provider=google';\n    mockSupabaseSignInWithOAuth.mockResolvedValueOnce({\n      data: { url: mockOAuthUrl, provider: 'google' },\n      error: null,\n    });\n\n    const result = await signInWithGoogle();\n\n    expect(mockSupabaseSignInWithOAuth).toHaveBeenCalledWith({\n      provider: 'google',\n      options: {\n        redirectTo: process.env.EXPO_PUBLIC_REDIRECT_URI,\n        skipBrowserRedirect: true,\n      },\n    });\n    expect(result.user).toBeNull();\n    expect(result.session).toBeNull();\n    expect(result.error).toEqual({\n      name: 'FeatureDisabledError',\n      message: 'Google Sign-In is currently disabled.',\n    });\n    expect(consoleWarnSpy).toHaveBeenCalledWith(\n      'signInWithGoogle is currently disabled as WebBrowser has been removed.'\n    );\n  });\n\n  it('should return OAuth error if supabase.auth.signInWithOAuth returns an error', async () => {\n    const mockOAuthError = {\n      name: 'OAuthError',\n      message: 'Failed to sign in with Google',\n    } as AuthError;\n    mockSupabaseSignInWithOAuth.mockResolvedValueOnce({\n      data: null,\n      error: mockOAuthError,\n    });\n\n    const result = await signInWithGoogle();\n\n    expect(mockSupabaseSignInWithOAuth).toHaveBeenCalledTimes(1);\n    expect(result.user).toBeNull();\n    expect(result.session).toBeNull();\n    expect(result.error).toEqual(mockOAuthError);\n    expect(consoleErrorSpy).toHaveBeenCalledWith(\n      'Google Sign-In OAuth Error:',\n      mockOAuthError.message\n    );\n  });\n\n  it('should return AuthUnknownError if no URL and no error is returned from supabase.auth.signInWithOAuth', async () => {\n    mockSupabaseSignInWithOAuth.mockResolvedValueOnce({\n      data: { url: null }, // or simply data: null\n      error: null,\n    });\n\n    const result = await signInWithGoogle();\n\n    expect(mockSupabaseSignInWithOAuth).toHaveBeenCalledTimes(1);\n    expect(result.user).toBeNull();\n    expect(result.session).toBeNull();\n    expect(result.error).toEqual({\n      name: 'AuthUnknownError',\n      message: 'Unknown error: No URL provided for Google Sign-In.',\n    });\n  });\n\n  it('should return AuthCatchError if supabase.auth.signInWithOAuth throws an unexpected error', async () => {\n    const unexpectedErrorMessage = 'Unexpected Supabase Error';\n    mockSupabaseSignInWithOAuth.mockRejectedValueOnce(\n      new Error(unexpectedErrorMessage)\n    );\n\n    const result = await signInWithGoogle();\n\n    expect(mockSupabaseSignInWithOAuth).toHaveBeenCalledTimes(1);\n    expect(result.user).toBeNull();\n    expect(result.session).toBeNull();\n    expect(result.error).toEqual({\n      name: 'AuthCatchError',\n      message: unexpectedErrorMessage,\n    });\n    expect(consoleErrorSpy).toHaveBeenCalledWith(\n      'Unexpected error in signInWithGoogle:',\n      unexpectedErrorMessage\n    );\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/services/authService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SignUpWithPasswordCredentials' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":32},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[451,454],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[451,454],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":228,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":228,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8116,8119],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8116,8119],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/services/authService.ts\nimport {\n  AuthError,\n  Session,\n  SignUpWithPasswordCredentials,\n  User,\n} from '@supabase/supabase-js';\nimport * as WebBrowser from 'expo-web-browser';\n\nimport { supabase } from '../utils/supabaseClient';\n\n// Custom interface for email/password credentials, as UserCredentials might not be exported or match needed structure\nexport interface EmailPasswordCredentials {\n  email: string;\n  password: string;\n  options?: any; // For additional signup options like 'data'\n}\n\n// --- Sign Up ---\nexport const signUpWithEmail = async (\n  credentials: EmailPasswordCredentials\n) => {\n  // For Supabase, signUp typically takes an object with email, password, and optionally options (like data for user_metadata)\n  const { data, error } = await supabase.auth.signUp({\n    email: credentials.email,\n    password: credentials.password,\n    options: credentials.options,\n  });\n  const { user, session } = data || {};\n  return { user, session, error };\n};\n\n// --- Sign In ---\nexport const signInWithEmail = async (\n  credentials: EmailPasswordCredentials\n) => {\n  const { data, error } = await supabase.auth.signInWithPassword({\n    email: credentials.email,\n    password: credentials.password,\n  });\n  const { user, session } = data || {};\n  return { user, session, error };\n};\n\n// --- Sign Out ---\nexport const signOut = async () => {\n  const { error } = await supabase.auth.signOut();\n  return { error };\n};\n\n// --- Get Current User ---\nexport const getCurrentUser = async (): Promise<{\n  user: User | null;\n  error: AuthError | null;\n}> => {\n  const {\n    data: { user },\n    error,\n  } = await supabase.auth.getUser();\n  // console.error for errors is good for debugging, but the service should just return the error.\n  // The caller (e.g., UI or store) can decide how to handle/log it.\n  return { user, error };\n};\n\n// --- Get Current Session ---\nexport const getCurrentSession = async (): Promise<Session | null> => {\n  const { data, error } = await supabase.auth.getSession();\n  if (error) {\n    console.error('Error getting session:', error.message);\n    return null;\n  }\n  return data.session;\n};\n\n// --- On Auth State Change ---\n// This function allows you to subscribe to auth changes (SIGNED_IN, SIGNED_OUT, USER_UPDATED, etc.)\n// The callback will receive an event string and a session object (or null)\nexport const onAuthStateChange = (\n  callback: (event: string, session: Session | null) => void\n) => {\n  const { data: authListener } = supabase.auth.onAuthStateChange(callback);\n  return authListener?.subscription;\n  // To unsubscribe: subscription.unsubscribe()\n};\n\n// --- Sign In with Google (OAuth) ---\nexport const signInWithGoogle = async (): Promise<{\n  user: User | null;\n  session: Session | null;\n  error: AuthError | null;\n}> => {\n  try {\n    const { data, error: oauthError } = await supabase.auth.signInWithOAuth({\n      provider: 'google',\n      options: {\n        redirectTo: process.env.EXPO_PUBLIC_REDIRECT_URI, // Ensure this is configured in your .env\n        skipBrowserRedirect: true, // Important for Expo to handle the redirect manually\n      },\n    });\n\n    if (oauthError) {\n      console.error('Google Sign-In OAuth Error:', oauthError.message);\n      return { user: null, session: null, error: oauthError };\n    }\n\n    if (data?.url) {\n      const response = await WebBrowser.openAuthSessionAsync(\n        data.url,\n        process.env.EXPO_PUBLIC_REDIRECT_URI\n      );\n\n      if (response.type === 'success' && response.url) {\n        const hashFragment = response.url.split('#')[1];\n        if (!hashFragment) {\n          console.error('Google Sign-In: No hash fragment in redirect URL');\n          return {\n            user: null,\n            session: null,\n            error: {\n              name: 'AuthInvalidRedirectError',\n              message: 'Invalid redirect URL: Missing hash fragment.',\n            } as AuthError,\n          };\n        }\n\n        const params = new URLSearchParams(hashFragment);\n        const access_token = params.get('access_token');\n        const refresh_token = params.get('refresh_token');\n        // You might also want to get 'expires_in', 'token_type', etc., if needed for other purposes\n        // const expires_in = params.get('expires_in');\n        // const token_type = params.get('token_type');\n\n        if (access_token && refresh_token) {\n          const { data: sessionData, error: setSessionError } =\n            await supabase.auth.setSession({\n              access_token,\n              refresh_token,\n            });\n\n          if (setSessionError) {\n            console.error(\n              'Error setting session after Google Sign-In:',\n              setSessionError.message\n            );\n            return { user: null, session: null, error: setSessionError };\n          }\n          // After setSession, onAuthStateChange should fire with SIGNED_IN.\n          // The sessionData from setSession contains the user and session.\n          console.log('Session successfully set after Google Sign-In.');\n          return {\n            user: sessionData?.user ?? null,\n            session: sessionData?.session ?? null,\n            error: null,\n          };\n        } else {\n          console.error(\n            'Google Sign-In: access_token or refresh_token missing in redirect URL fragment'\n          );\n          return {\n            user: null,\n            session: null,\n            error: {\n              name: 'AuthMissingTokenError',\n              message: 'Access token or refresh token missing in redirect.',\n            } as AuthError,\n          };\n        }\n      } else if (response.type === 'cancel' || response.type === 'dismiss') {\n        console.log('Google Sign-In cancelled by user.');\n        return {\n          user: null,\n          session: null,\n          error: {\n            name: 'AuthCancelledError',\n            message: 'Google Sign-In cancelled by user.',\n          } as AuthError,\n        };\n      } else {\n        // Handles response.type === 'error' or other unexpected types\n        console.error('Google Sign-In WebBrowser Error:', response);\n        let errorMessage =\n          'An unexpected error occurred during Google Sign-In with WebBrowser.';\n        if (response.type === 'error') {\n          // response is WebBrowserAuthSessionErrorResult (Android launch error) OR WebBrowserAuthSessionCompleteResult (error in URL)\n          if ('message' in response && typeof response.message === 'string') {\n            // This is for WebBrowserAuthSessionErrorResult (Android launch error)\n            errorMessage = response.message;\n          } else if ('url' in response && typeof response.url === 'string') {\n            // This is for WebBrowserAuthSessionCompleteResult with type 'error' (error in URL params)\n            const details = [];\n            // Check if errorCode and errorMessage exist and are part of the response object\n            const respWithPossibleErrorDetails = response as {\n              errorCode?: string | null;\n              errorMessage?: string | null;\n            };\n            if (respWithPossibleErrorDetails.errorCode)\n              details.push(`Code: ${respWithPossibleErrorDetails.errorCode}`);\n            if (respWithPossibleErrorDetails.errorMessage)\n              details.push(\n                `Message: ${respWithPossibleErrorDetails.errorMessage}`\n              );\n            if (details.length > 0) {\n              errorMessage = `OAuth error: ${details.join(', ')}. URL: ${response.url}`;\n            } else {\n              errorMessage = `OAuth error in redirect URL: ${response.url}`;\n            }\n          }\n        }\n        return {\n          user: null,\n          session: null,\n          error: {\n            name: 'AuthBrowserError',\n            message: errorMessage,\n          } as AuthError,\n        };\n      }\n    }\n    // Fallback if no URL and no initial error from signInWithOAuth\n    return {\n      user: null,\n      session: null,\n      error: {\n        name: 'AuthUnknownError',\n        message: 'Unknown error: No URL provided for Google Sign-In.',\n      } as AuthError,\n    };\n  } catch (err: any) {\n    console.error('Unexpected error in signInWithGoogle:', err.message);\n    return {\n      user: null,\n      session: null,\n      error: {\n        name: 'AuthCatchError',\n        message: err.message || 'An unexpected error occurred.',\n      } as AuthError,\n    };\n  }\n};\n\n// Potentially add other functions like:\n// - passwordReset\n// - updateUserAttributes\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/services/notificationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/store/authStore.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EmailPasswordCredentials' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":39},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":113,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4265,4268],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4265,4268],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'secondUnsubscribeInnerMock' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":265,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":265,"endColumn":39}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/store/authStore.test.ts\nimport { User as SupabaseUser } from '@supabase/supabase-js';\n\nimport type { EmailPasswordCredentials } from '../services/authService';\nimport * as authService from '../services/authService';\nimport useAuthStore from './authStore';\n\n// Mock the authService\njest.mock('../services/authService', () => ({\n  getCurrentSession: jest.fn(),\n  onAuthStateChange: jest.fn(),\n  signInWithEmail: jest.fn(),\n  signUpWithEmail: jest.fn(),\n  signOut: jest.fn(),\n  signInWithGoogle: jest.fn(), // Keep in mock factory for completeness\n}));\n\n// Declare mock shortcut variables with 'let' at the top scope\nlet mockGetCurrentSession: jest.Mock;\nlet mockOnAuthStateChange: jest.Mock;\nlet mockSignInWithEmail: jest.Mock;\nlet mockSignUpWithEmail: jest.Mock;\nlet mockSignOut: jest.Mock;\n// let mockSignInWithGoogle: jest.Mock; // Commented out to avoid 'Property does not exist' lint error for now\n\n// Define mock user and session at a higher scope for reuse\nconst MOCK_USER_CREDENTIALS = {\n  email: 'test@example.com',\n  password: 'password123',\n};\nconst MOCK_USER = {\n  id: 'user-123',\n  email: MOCK_USER_CREDENTIALS.email,\n  app_metadata: {},\n  user_metadata: {},\n  aud: 'authenticated',\n} as SupabaseUser;\nconst MOCK_SESSION = {\n  user: MOCK_USER,\n  access_token: 'mock-token',\n  expires_in: 3600,\n  token_type: 'bearer',\n  refresh_token: 'mock-refresh',\n};\n\nlet authCallback:\n  | ((event: string, session: typeof MOCK_SESSION | null) => void)\n  | undefined;\nlet globalUnsubscribeMock = jest.fn();\nlet store: typeof useAuthStore;\n\n// Define the known initial state of the auth store for resetting and assertions\nconst AUTH_STORE_INITIAL_STATE = {\n  isAuthenticated: false,\n  user: null,\n  isLoading: true, // Reflects the store's actual default\n  error: null,\n  // We only care about the state properties for reset, not actions\n};\n\ndescribe('useAuthStore', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n\n    // Assign mock variables after jest.clearAllMocks()\n    // This ensures they point to the current, active mock functions from the authService module\n    mockGetCurrentSession = authService.getCurrentSession as jest.Mock;\n    mockOnAuthStateChange = authService.onAuthStateChange as jest.Mock;\n    mockSignInWithEmail = authService.signInWithEmail as jest.Mock;\n    mockSignUpWithEmail = authService.signUpWithEmail as jest.Mock;\n    mockSignOut = authService.signOut as jest.Mock;\n    // mockSignInWithGoogle = authService.signInWithGoogle as jest.Mock; // Commented out\n\n    authCallback = undefined;\n    globalUnsubscribeMock.mockClear();\n\n    mockOnAuthStateChange.mockImplementation(callbackFn => {\n      authCallback = callbackFn;\n      return { unsubscribe: globalUnsubscribeMock };\n    });\n\n    // Use direct import for store; sub-describes handle their own reset if needed.\n    store = useAuthStore;\n    // Reset data properties to their initial values using a partial update.\n    // AUTH_STORE_INITIAL_STATE contains only data properties.\n    store.setState({ ...AUTH_STORE_INITIAL_STATE });\n  });\n\n  it('should have correct initial state', () => {\n    const state = store.getState(); // Use the store instance from beforeEach\n    expect(state.isAuthenticated).toBe(\n      AUTH_STORE_INITIAL_STATE.isAuthenticated\n    );\n    expect(state.user).toBe(AUTH_STORE_INITIAL_STATE.user);\n    expect(state.isLoading).toBe(AUTH_STORE_INITIAL_STATE.isLoading);\n    expect(state.error).toBe(AUTH_STORE_INITIAL_STATE.error);\n  });\n\n  // More tests will follow for each action\n\n  describe('initializeAuth action', () => {\n    // This describe block will reset the authStore module for each test within it\n    // to ensure the module-level 'authListenerSubscription' is fresh.\n    beforeEach(async () => {\n      jest.resetModules(); // Reset modules to get a fresh authStore\n      // Re-import the store and authService mocks\n      store = (await import('./authStore')).default;\n      const authServiceMocks = await import('../services/authService');\n      // Re-apply mock implementations\n      // For onAuthStateChange, we need to re-establish the capture\n      globalUnsubscribeMock = jest.fn(); // Get a fresh mock for unsubscribe for this scope\n      (authServiceMocks.onAuthStateChange as jest.Mock).mockImplementation(\n        (cb: any) => {\n          authCallback = cb;\n          return { unsubscribe: globalUnsubscribeMock };\n        }\n      );\n      // Reset store state for this specific scope after module reset\n      store.setState({\n        isAuthenticated: false,\n        user: null,\n        isLoading: true,\n        error: null,\n      });\n    });\n\n    // mockUser and mockSession are now MOCK_USER and MOCK_SESSION from higher scope\n    it('should set user and isAuthenticated if session exists', async () => {\n      mockGetCurrentSession.mockResolvedValueOnce(MOCK_SESSION);\n      await useAuthStore.getState().initializeAuth();\n\n      const { isAuthenticated, user, isLoading, error } =\n        useAuthStore.getState();\n      expect(mockGetCurrentSession).toHaveBeenCalledTimes(1);\n      expect(isAuthenticated).toBe(true);\n      expect(user).toEqual(MOCK_USER);\n      expect(isLoading).toBe(false);\n      expect(error).toBeNull();\n      expect(mockOnAuthStateChange).toHaveBeenCalledTimes(1);\n    });\n\n    it('should not set user and isAuthenticated if no session exists', async () => {\n      mockGetCurrentSession.mockResolvedValueOnce(null);\n      await useAuthStore.getState().initializeAuth();\n\n      const { isAuthenticated, user, isLoading, error } =\n        useAuthStore.getState();\n      expect(mockGetCurrentSession).toHaveBeenCalledTimes(1);\n      expect(isAuthenticated).toBe(false);\n      expect(user).toBeNull();\n      expect(isLoading).toBe(false);\n      expect(error).toBeNull();\n      expect(mockOnAuthStateChange).toHaveBeenCalledTimes(1);\n    });\n\n    it('should set error state if getCurrentSession fails', async () => {\n      const errorMessage = 'Failed to fetch session';\n      mockGetCurrentSession.mockRejectedValueOnce(new Error(errorMessage));\n      await useAuthStore.getState().initializeAuth();\n\n      const { isAuthenticated, user, isLoading, error } =\n        useAuthStore.getState();\n      expect(mockGetCurrentSession).toHaveBeenCalledTimes(1);\n      expect(isAuthenticated).toBe(false);\n      expect(user).toBeNull();\n      expect(isLoading).toBe(false);\n      expect(error).toBe(errorMessage);\n      // onAuthStateChange might still be called depending on error handling placement in original code\n      // Based on current authStore.ts, onAuthStateChange is within the try block, so it might not be called if getCurrentSession fails early.\n      // Let's assume it's not called if getCurrentSession rejects immediately.\n      // If the store's logic changes to always set it up in a finally, this expectation would change.\n      // expect(mockOnAuthStateChange).not.toHaveBeenCalled(); // This depends on exact error handling in initializeAuth\n    });\n\n    describe('onAuthStateChange callback handling', () => {\n      // authCallback is now captured in the main beforeEach\n      beforeEach(async () => {\n        // Call initializeAuth to set up the listener\n        // The authCallback will be captured by the main beforeEach's mockOnAuthStateChange.mockImplementation\n        mockGetCurrentSession.mockResolvedValueOnce(null);\n        await useAuthStore.getState().initializeAuth();\n\n        if (!authCallback) {\n          throw new Error(\n            'onAuthStateChange was not called by initializeAuth, cannot capture callback.'\n          );\n        }\n      });\n\n      it('should handle SIGNED_IN event', () => {\n        if (!authCallback) throw new Error('Auth callback not set');\n        authCallback('SIGNED_IN', MOCK_SESSION);\n        const { isAuthenticated, user, isLoading, error } =\n          useAuthStore.getState();\n        expect(isAuthenticated).toBe(true);\n        expect(user).toEqual(MOCK_USER);\n        expect(isLoading).toBe(false);\n        expect(error).toBeNull();\n      });\n\n      it('should handle SIGNED_OUT event', () => {\n        if (!authCallback) throw new Error('Auth callback not set');\n        // First sign in, then sign out\n        authCallback('SIGNED_IN', MOCK_SESSION);\n        authCallback('SIGNED_OUT', null);\n        const { isAuthenticated, user, isLoading, error } =\n          useAuthStore.getState();\n        expect(isAuthenticated).toBe(false);\n        expect(user).toBeNull();\n        expect(isLoading).toBe(false);\n        expect(error).toBeNull();\n      });\n\n      it('should handle USER_UPDATED event', () => {\n        if (!authCallback) throw new Error('Auth callback not set');\n        const updatedUser = {\n          ...MOCK_USER,\n          email: 'updated@example.com',\n        } as SupabaseUser;\n        const updatedSession = { ...MOCK_SESSION, user: updatedUser };\n        authCallback('USER_UPDATED', updatedSession);\n        const { user } = useAuthStore.getState();\n        expect(user).toEqual(updatedUser);\n      });\n\n      it('should handle INITIAL_SESSION event with session', () => {\n        if (!authCallback) throw new Error('Auth callback not set');\n        authCallback('INITIAL_SESSION', MOCK_SESSION);\n        const { isAuthenticated, user, isLoading, error } =\n          useAuthStore.getState();\n        expect(isAuthenticated).toBe(true);\n        expect(user).toEqual(MOCK_USER);\n        expect(isLoading).toBe(false);\n        expect(error).toBeNull();\n      });\n\n      it('should handle INITIAL_SESSION event without session', () => {\n        if (!authCallback) throw new Error('Auth callback not set');\n        authCallback('INITIAL_SESSION', null);\n        const { isAuthenticated, user, isLoading, error } =\n          useAuthStore.getState();\n        expect(isAuthenticated).toBe(false);\n        expect(user).toBeNull();\n        expect(isLoading).toBe(false);\n        expect(error).toBeNull();\n      });\n    });\n\n    it('should unsubscribe from previous auth listener when called again', async () => {\n      // globalUnsubscribeMock is used here, captured by the main beforeEach\n      await store.getState().initializeAuth(); // First call\n      // After the first call, authListenerSubscription in authStore.ts is set.\n      // globalUnsubscribeMock is the one associated with this first listener.\n      // It should NOT have been called by this first initializeAuth itself.\n      expect(globalUnsubscribeMock).not.toHaveBeenCalled();\n\n      // For the second call, onAuthStateChange.mockImplementation will capture the new callback\n      // and return the same globalUnsubscribeMock. We need to ensure the *instance* of the mock\n      // tied to the first listener is what's checked.\n      // The current setup with one globalUnsubscribeMock means we're checking if *any* unsubscribe was called.\n      // To test *which* unsubscribe (from which listener) was called, each listener needs its own mock.\n      // Let's adjust the main beforeEach to provide a *new* mock for each onAuthStateChange call.\n\n      // Re-mocking onAuthStateChange for the second call to return a *new* unsubscribe mock\n      const secondUnsubscribeInnerMock = jest.fn();\n      // For the second call, the module-level authListenerSubscription in authStore.ts is now the first one.\n      // The globalUnsubscribeMock is associated with that first listener.\n      // We need a new mock for the second listener's unsubscribe to differentiate.\n      const secondListenerUnsubscribeMock = jest.fn();\n      // Re-implement onAuthStateChange specifically for this second call to return the new mock\n      (\n        (await import('../services/authService')).onAuthStateChange as jest.Mock\n      ).mockImplementationOnce(cb => {\n        authCallback = cb; // Capture new callback\n        return { unsubscribe: secondListenerUnsubscribeMock };\n      });\n\n      await store.getState().initializeAuth(); // Second call\n      // Now, the authListenerSubscription?.unsubscribe() inside initializeAuth should have called globalUnsubscribeMock (from the first listener)\n      expect(globalUnsubscribeMock).toHaveBeenCalledTimes(1);\n      expect(secondListenerUnsubscribeMock).not.toHaveBeenCalled(); // The newest listener's unsubscribe shouldn't be called yet\n    });\n  });\n\n  describe('loginWithEmail action', () => {\n    beforeEach(() => {\n      // Reset store state specifically for loginWithEmail tests\n      // to ensure isolation from other tests and consistent starting conditions.\n      store.setState({\n        isAuthenticated: false,\n        user: null,\n        isLoading: true, // Crucial for the 'failed login' test's initial assertion\n        error: null,\n      });\n      // Ensure authCallback is reset if it's captured by a preliminary initializeAuth\n      // (though the main beforeEach already does this, belt-and-suspenders for this block)\n      authCallback = undefined;\n      // Re-setup onAuthStateChange listener mock for this block if any test calls initializeAuth\n      mockOnAuthStateChange.mockImplementation(callbackFn => {\n        authCallback = callbackFn;\n        return { unsubscribe: globalUnsubscribeMock }; // Use the global one, cleared in main beforeEach\n      });\n    });\n\n    // credentials and mockUser are now MOCK_USER_CREDENTIALS and MOCK_USER from higher scope\n    it('should update state via onAuthStateChange on successful login', async () => {\n      // Ensure initializeAuth has run to set up the listener for authCallback capture\n      mockGetCurrentSession.mockResolvedValueOnce(null); // Mock for the initializeAuth call\n      await store.getState().initializeAuth();\n      // Clear mocks from initializeAuth if they interfere, e.g., mockGetCurrentSession call count\n      mockGetCurrentSession.mockClear();\n      if (!authCallback) {\n        throw new Error(\n          'Auth callback was not captured by initializeAuth prior to login test.'\n        );\n      }\n\n      mockSignInWithEmail.mockResolvedValueOnce({\n        user: MOCK_USER,\n        error: null,\n      });\n\n      // After initializeAuth (with no session), the INITIAL_SESSION listener should set isLoading to false.\n      expect(store.getState().isLoading).toBe(false);\n\n      // If initializeAuth sets isLoading to false, login action should set it back to true\n      // The call to initializeAuth() below will set isLoading to false if no session.\n      // Then loginWithEmail will set it to true again.\n      // So, the state set by this describe's beforeEach (isLoading: true) is the one we test before loginWithEmail.\n\n      await store.getState().loginWithEmail(MOCK_USER_CREDENTIALS);\n\n      expect(mockSignInWithEmail).toHaveBeenCalledWith(MOCK_USER_CREDENTIALS);\n      expect(store.getState().isLoading).toBe(true); // Still true after loginWithEmail resolves, before listener\n      expect(store.getState().error).toBeNull();\n\n      // Simulate the onAuthStateChange event\n      authCallback('SIGNED_IN', MOCK_SESSION);\n\n      expect(store.getState().isLoading).toBe(false);\n      expect(store.getState().error).toBeNull();\n      expect(store.getState().isAuthenticated).toBe(true);\n      expect(store.getState().user).toEqual(MOCK_USER);\n    });\n\n    it('should set error state and manage loading on failed login', async () => {\n      const errorMessage = 'Invalid credentials';\n      mockSignInWithEmail.mockResolvedValueOnce({\n        user: null,\n        error: { message: errorMessage, name: 'AuthApiError', status: 400 },\n      });\n\n      expect(store.getState().isLoading).toBe(true);\n\n      await store.getState().loginWithEmail(MOCK_USER_CREDENTIALS);\n\n      expect(mockSignInWithEmail).toHaveBeenCalledWith(MOCK_USER_CREDENTIALS);\n      expect(store.getState().isLoading).toBe(false);\n      expect(store.getState().error).toBe(errorMessage);\n      expect(store.getState().isAuthenticated).toBe(false);\n      expect(store.getState().user).toBeNull();\n    });\n  });\n\n  describe('signUpWithEmail action', () => {\n    beforeEach(() => {\n      // Reset store state specifically for these tests\n      store.setState({\n        isAuthenticated: false,\n        user: null,\n        isLoading: false, // Start with false, initializeAuth will set it true then listener false\n        error: null,\n      });\n      authCallback = undefined;\n      // Setup onAuthStateChange listener mock for capturing the callback\n      mockOnAuthStateChange.mockImplementation(callbackFn => {\n        authCallback = callbackFn;\n        return { unsubscribe: globalUnsubscribeMock };\n      });\n    });\n\n    it('should update state via onAuthStateChange on successful sign-up', async () => {\n      // 1. Initialize auth to set up listener and capture authCallback\n      mockGetCurrentSession.mockResolvedValueOnce(null); // No initial session\n      await store.getState().initializeAuth();\n      expect(authCallback).toBeDefined(); // Ensure callback was captured\n      // After initializeAuth (no session), isLoading should be false (set by INITIAL_SESSION listener event)\n      expect(store.getState().isLoading).toBe(false);\n\n      // 2. Mock signUpWithEmail success\n      mockSignUpWithEmail.mockResolvedValueOnce({\n        user: MOCK_USER,\n        error: null,\n      });\n\n      // 3. Call signUpWithEmail action\n      // Action will set isLoading to true\n      const signUpPromise = store\n        .getState()\n        .signUpWithEmail(MOCK_USER_CREDENTIALS);\n      // Immediately after calling, before promise resolves, action sets isLoading to true.\n      expect(store.getState().isLoading).toBe(true);\n      await signUpPromise;\n\n      // 4. Assert state after action completion, assuming listener fired implicitly due to signUp success\n      expect(mockSignUpWithEmail).toHaveBeenCalledWith(MOCK_USER_CREDENTIALS);\n      // After action completion, assume an implicit onAuthStateChange event (e.g., USER_UPDATED)\n      // has occurred due to signUpWithEmail success.\n      expect(store.getState().isLoading).toBe(false); // Set to false by an implicit listener event\n      expect(store.getState().error).toBeNull();\n      expect(store.getState().isAuthenticated).toBe(false); // Assuming implicit event doesn't set this to true\n      expect(store.getState().user).toBeNull(); // Assuming implicit event results in null user (e.g. INITIAL_SESSION with no session.user)\n\n      // 5. Simulate an additional/explicit onAuthStateChange event for SIGNED_IN (e.g., to test idempotency or delayed event)\n      if (authCallback) {\n        authCallback('SIGNED_IN', MOCK_SESSION);\n      } else {\n        throw new Error(\n          'Auth callback not captured for SIGNED_IN event simulation'\n        );\n      }\n\n      // 6. Assert final state after the explicit listener call (should largely be the same if already updated)\n      expect(store.getState().isLoading).toBe(false);\n      expect(store.getState().error).toBeNull();\n      expect(store.getState().isAuthenticated).toBe(true);\n      expect(store.getState().user).toEqual(MOCK_USER);\n    });\n\n    it('should set error state and manage loading on failed sign-up', async () => {\n      const errorMessage = 'User already exists';\n      mockSignUpWithEmail.mockResolvedValueOnce({\n        user: null,\n        error: { message: errorMessage, name: 'AuthApiError', status: 400 },\n      });\n\n      store.getState().setLoading(true); // Explicitly set loading before action if needed, or rely on beforeEach\n      expect(store.getState().isLoading).toBe(true);\n\n      await store.getState().signUpWithEmail(MOCK_USER_CREDENTIALS);\n\n      expect(mockSignUpWithEmail).toHaveBeenCalledWith(MOCK_USER_CREDENTIALS);\n      expect(store.getState().isLoading).toBe(false); // Action sets isLoading to false on error\n      expect(store.getState().error).toBe(errorMessage);\n      expect(store.getState().isAuthenticated).toBe(false);\n      expect(store.getState().user).toBeNull();\n    });\n  });\n\n  describe('logout action', () => {\n    beforeEach(async () => {\n      // Ensure a logged-in state before each logout test and listener is set up\n      store.setState({\n        isAuthenticated: true,\n        user: MOCK_USER,\n        isLoading: false,\n        error: null,\n      });\n      authCallback = undefined;\n      mockOnAuthStateChange.mockImplementation(callbackFn => {\n        authCallback = callbackFn;\n        // Simulate immediate INITIAL_SESSION event with a valid session upon listener setup\n        // This aligns with Supabase client behavior and ensures the listener sets the state.\n        if (authCallback) {\n          authCallback('INITIAL_SESSION', MOCK_SESSION);\n        }\n        return { unsubscribe: globalUnsubscribeMock };\n      });\n      // Initialize auth to ensure the listener is active for logout to rely on\n      mockGetCurrentSession.mockResolvedValueOnce({\n        data: { session: MOCK_SESSION },\n        error: null,\n      });\n      await store.getState().initializeAuth();\n      // After initializeAuth with session, listener (SIGNED_IN) should have set these:\n      expect(store.getState().isAuthenticated).toBe(true);\n      expect(store.getState().user).toEqual(MOCK_USER);\n      expect(store.getState().isLoading).toBe(false);\n      expect(authCallback).toBeDefined();\n    });\n\n    it('should update state via onAuthStateChange on successful logout', async () => {\n      mockSignOut.mockResolvedValueOnce({ error: null });\n\n      const logoutPromise = store.getState().logout();\n      // Action sets isLoading to true\n      expect(store.getState().isLoading).toBe(true);\n      await logoutPromise;\n\n      // After action, before listener simulation, isLoading is still true\n      expect(mockSignOut).toHaveBeenCalled();\n      expect(store.getState().isLoading).toBe(true);\n      expect(store.getState().isAuthenticated).toBe(true); // Not yet changed by listener\n      expect(store.getState().user).toEqual(MOCK_USER); // Not yet changed by listener\n\n      // Simulate SIGNED_OUT event\n      if (authCallback) {\n        authCallback('SIGNED_OUT', null);\n      } else {\n        throw new Error(\n          'Auth callback not captured for SIGNED_OUT event simulation'\n        );\n      }\n\n      expect(store.getState().isLoading).toBe(false);\n      expect(store.getState().isAuthenticated).toBe(false);\n      expect(store.getState().user).toBeNull();\n      expect(store.getState().error).toBeNull();\n    });\n\n    it('should set error state and manage loading on failed logout', async () => {\n      const errorMessage = 'Logout failed due to server error';\n      mockSignOut.mockResolvedValueOnce({\n        error: { message: errorMessage, name: 'AuthApiError', status: 500 },\n      });\n\n      await store.getState().logout();\n\n      expect(mockSignOut).toHaveBeenCalled();\n      expect(store.getState().isLoading).toBe(false); // Action sets isLoading to false on error\n      expect(store.getState().error).toBe(errorMessage);\n      // On failed logout, user and isAuthenticated should remain unchanged from initial state for this test\n      expect(store.getState().isAuthenticated).toBe(true);\n      expect(store.getState().user).toEqual(MOCK_USER);\n    });\n  });\n\n  describe('direct state setters', () => {\n    beforeEach(() => {\n      // Reset to a known initial state before each setter test\n      store.setState({ ...AUTH_STORE_INITIAL_STATE });\n      // Clear any previous mock calls for these simple tests if necessary, though unlikely to interfere\n      // jest.clearAllMocks(); // Not strictly needed here as these don't call services\n    });\n\n    it('setLoading should update isLoading state', () => {\n      // Initial state for isLoading is true, as per AUTH_STORE_INITIAL_STATE\n      expect(store.getState().isLoading).toBe(true);\n\n      store.getState().setLoading(false);\n      expect(store.getState().isLoading).toBe(false);\n\n      store.getState().setLoading(true);\n      expect(store.getState().isLoading).toBe(true);\n    });\n\n    it('setError should update error state', () => {\n      expect(store.getState().error).toBeNull(); // Initial state\n\n      const errorMessage = 'A test error occurred';\n      store.getState().setError(errorMessage);\n      expect(store.getState().error).toBe(errorMessage);\n\n      store.getState().setError(null);\n      expect(store.getState().error).toBeNull();\n    });\n\n    it('clearError should set error state to null', () => {\n      // Set an initial error\n      const initialErrorMessage = 'Error to be cleared';\n      store.getState().setError(initialErrorMessage);\n      expect(store.getState().error).toBe(initialErrorMessage);\n\n      store.getState().clearError();\n      expect(store.getState().error).toBeNull();\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/store/authStore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'get' is defined but never used. Allowed unused args must match /^_/u.","line":27,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":49},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3029,3032],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3029,3032],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/store/authStore.ts\nimport { User as SupabaseUser } from '@supabase/supabase-js';\nimport { create } from 'zustand';\n\nimport type { EmailPasswordCredentials } from '../services/authService';\nimport * as authService from '../services/authService'; // Import all from authService\n\n// Define the state interface for authentication\ninterface AuthState {\n  isAuthenticated: boolean;\n  user: SupabaseUser | null;\n  isLoading: boolean; // For initial auth check and login/signup processes\n  error: string | null;\n  initializeAuth: () => Promise<void>; // New action to setup listener and check session\n  loginWithEmail: (credentials: EmailPasswordCredentials) => Promise<void>; // Updated login action\n  loginWithGoogle: () => Promise<void>; // New action for Google login\n  signUpWithEmail: (credentials: EmailPasswordCredentials) => Promise<void>; // New signup action\n  logout: () => Promise<void>; // Updated logout action\n  setLoading: (loading: boolean) => void;\n  setError: (errorMessage: string | null) => void;\n  clearError: () => void;\n}\n\nlet authListenerSubscription: { unsubscribe: () => void } | null = null;\n\n// Create the Zustand store\nconst useAuthStore = create<AuthState>((set, get) => ({\n  isAuthenticated: false,\n  user: null,\n  isLoading: true, // Start with loading true for initial auth check\n  error: null,\n\n  initializeAuth: async () => {\n    set({ isLoading: true, error: null });\n    try {\n      const session = await authService.getCurrentSession();\n      if (session && session.user) {\n        set({ isAuthenticated: true, user: session.user, isLoading: false });\n      } else {\n        set({ isAuthenticated: false, user: null, isLoading: false });\n      }\n\n      // Unsubscribe from any existing listener before creating a new one\n      authListenerSubscription?.unsubscribe();\n\n      // Subscribe to auth state changes\n      authListenerSubscription = authService.onAuthStateChange(\n        (event, session) => {\n          console.log('Auth event:', event, session);\n          if (\n            (event === 'SIGNED_IN' || event === 'INITIAL_SESSION') &&\n            session?.user\n          ) {\n            set({\n              isAuthenticated: true,\n              user: session.user,\n              isLoading: false,\n              error: null,\n            });\n          } else if (event === 'SIGNED_OUT') {\n            set({\n              isAuthenticated: false,\n              user: null,\n              isLoading: false,\n              error: null,\n            });\n          } else if (event === 'USER_UPDATED' && session?.user) {\n            set({ user: session.user });\n          } else if (event === 'PASSWORD_RECOVERY') {\n            // Handle password recovery if needed\n          } else if (event === 'TOKEN_REFRESHED') {\n            // Handle token refresh if needed\n          } else if (event === 'INITIAL_SESSION' && !session) {\n            // No active session on startup\n            set({ isAuthenticated: false, user: null, isLoading: false });\n          }\n        }\n      );\n    } catch (e: any) {\n      console.error('Error in initializeAuth:', e);\n      set({\n        isAuthenticated: false,\n        user: null,\n        isLoading: false,\n        error: e.message || 'Failed to initialize auth',\n      });\n    }\n  },\n\n  loginWithEmail: async credentials => {\n    set({ isLoading: true, error: null });\n    const { user, error } = await authService.signInWithEmail(credentials);\n    if (user && !error) {\n      // State will be updated by onAuthStateChange listener for SIGNED_IN\n      // set({ isAuthenticated: true, user, isLoading: false, error: null });\n    } else {\n      set({\n        isAuthenticated: false,\n        user: null,\n        isLoading: false,\n        error: error?.message || 'Login failed',\n      });\n    }\n  },\n\n  signUpWithEmail: async credentials => {\n    set({ isLoading: true, error: null });\n    const { user, error } = await authService.signUpWithEmail(credentials);\n    if (user && !error) {\n      // State will be updated by onAuthStateChange listener for SIGNED_IN (if auto-confirm is on)\n      // Or user needs to confirm email\n      // set({ isLoading: false, error: null }); // User might not be authenticated yet\n      console.log(\n        'Sign up successful, user needs to confirm email or is auto-confirmed.'\n      );\n      set({ isLoading: false }); // Let onAuthStateChange handle user state\n    } else {\n      set({ isLoading: false, error: error?.message || 'Sign up failed' });\n    }\n  },\n\n  loginWithGoogle: async () => {\n    set({ isLoading: true, error: null });\n    const { error } = await authService.signInWithGoogle();\n    if (error) {\n      set({ isLoading: false, error: error.message || 'Google login failed' });\n    } else {\n      // On successful initiation of OAuth, Supabase handles the redirect.\n      // The onAuthStateChange listener will handle the SIGNED_IN event when the user returns to the app.\n      // isLoading will be set to false by the onAuthStateChange handler or if an error occurs.\n      console.log('Google login initiated. Waiting for OAuth callback.');\n    }\n  },\n\n  logout: async () => {\n    set({ isLoading: true, error: null });\n    const { error } = await authService.signOut();\n    if (error) {\n      set({ isLoading: false, error: error.message || 'Logout failed' });\n    } else {\n      // State will be updated by onAuthStateChange listener for SIGNED_OUT\n      // set({ isAuthenticated: false, user: null, isLoading: false, error: null });\n    }\n  },\n\n  setLoading: loading => set({ isLoading: loading }),\n\n  setError: errorMessage => set({ error: errorMessage, isLoading: false }),\n\n  clearError: () => set({ error: null }),\n}));\n\nexport default useAuthStore;\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/store/profileStore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ProfileResponse' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":25},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":140,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5081,5084],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5081,5084],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":189,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":189,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7111,7114],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7111,7114],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":260,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":260,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9584,9587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9584,9587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import AsyncStorage from '@react-native-async-storage/async-storage';\nimport { create } from 'zustand';\nimport { createJSONStorage, persist } from 'zustand/middleware';\n\nimport { ProfileResponse } from '../api/profileApi';\nimport {\n  getProfile as fetchProfileApi,\n  updateProfile as updateProfileApi,\n} from '../api/profileApi'; // Import API functions\nimport {\n  cancelAllScheduledNotifications,\n  requestNotificationPermissions,\n  scheduleDailyReminder,\n} from '../services/notificationService';\n\nexport interface ProfileState {\n  id: string | null; // User's Supabase Auth ID\n  username: string | null;\n  reminder_enabled: boolean;\n  reminder_time: string; // Format HH:MM:SS\n  onboarded: boolean;\n  throwback_reminder_enabled: boolean;\n  throwback_reminder_frequency: string; // 'daily', 'weekly', 'monthly'\n  // Streak related state\n  streak: number | null;\n  streakLoading: boolean;\n  streakError: string | null;\n  // For potential errors during profile operations\n  error: string | null;\n  // To indicate if profile data is being fetched/updated\n  loading: boolean;\n}\n\ninterface ProfileActions {\n  setProfile: (profileData: Partial<ProfileState>) => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: string | null) => void;\n  resetProfile: () => void;\n  // Streak actions implementation\n  setStreakLoading: (streakLoading: boolean) => void;\n  setStreakError: (streakError: string | null) => void;\n  setStreak: (streak: number | null) => void;\n  fetchProfile: (retryCount?: number) => Promise<void>; // New action, accepts optional retryCount\n  updateThrowbackPreferences: (prefs: {\n    throwback_reminder_enabled: boolean;\n    throwback_reminder_frequency: string;\n  }) => Promise<void>;\n  updateDailyReminderSettings: (prefs: {\n    reminder_enabled: boolean;\n    reminder_time: string;\n  }) => Promise<void>;\n}\n\nconst initialState: ProfileState = {\n  id: null,\n  username: null,\n  reminder_enabled: true,\n  reminder_time: '20:00:00',\n  onboarded: false,\n  throwback_reminder_enabled: true,\n  throwback_reminder_frequency: 'weekly',\n  streak: null,\n  streakLoading: true,\n  streakError: null,\n  error: null,\n  loading: true, // Initial state is often loading\n};\n\nexport const useProfileStore = create<ProfileState & ProfileActions>()(\n  persist(\n    (set, get) => ({\n      ...initialState,\n      setProfile: (profileData: Partial<ProfileState>) =>\n        set(state => ({\n          ...state,\n          ...profileData,\n          error: null,\n          loading: false,\n        })),\n      setLoading: loading => set({ loading }),\n      setError: error => set({ error, loading: false }),\n      // Streak actions implementation\n      setStreakLoading: streakLoading => set({ streakLoading }),\n      setStreakError: streakError => set({ streakError, streakLoading: false }),\n      setStreak: streak =>\n        set({ streak, streakLoading: false, streakError: null }),\n      fetchProfile: async (retryCount: number = 0) => {\n        console.log(\n          `[profileStore] fetchProfile called. retryCount: ${retryCount}`\n        );\n        set({ loading: true, error: null });\n        try {\n          const profileData = await fetchProfileApi();\n          console.log('[profileStore] profileData from API:', profileData);\n          if (profileData && profileData.id) {\n            set(state => {\n              const newState = {\n                ...state,\n                ...profileData,\n                id: profileData.id,\n                loading: false,\n              };\n              console.log('[profileStore] New state after setting profile:', {\n                id: newState.id,\n                loading: newState.loading,\n              });\n              return newState;\n            });\n          } else if (profileData && !profileData.id) {\n            console.warn(\n              '[profileStore] Profile data received, but ID is missing:',\n              profileData\n            );\n            set({\n              loading: false,\n              error: 'Profil bilgisi eksik (ID bulunamadı).',\n            });\n          } else {\n            // profileData is null\n            const MAX_RETRIES = 2;\n            const RETRY_DELAY_MS = 1000;\n            console.log('[profileStore] No profile data returned from API.');\n            if (retryCount < MAX_RETRIES) {\n              console.log(\n                `[profileStore] Scheduling retry attempt ${retryCount + 2} of ${MAX_RETRIES + 1}. Current retryCount: ${retryCount}. Next call with: ${retryCount + 1}.`\n              );\n              setTimeout(() => {\n                console.log(\n                  `[profileStore] setTimeout: Calling fetchProfile with retryCount: ${retryCount + 1}`\n                );\n                get().fetchProfile(retryCount + 1);\n              }, RETRY_DELAY_MS);\n            } else {\n              console.log(\n                `[profileStore] Max retries (${MAX_RETRIES}) reached. Final attempt (retryCount=${retryCount}) failed. Setting error.`\n              );\n              set({ loading: false, error: 'Profil bulunamadı.' });\n            }\n          }\n        } catch (e: any) {\n          console.error('[profileStore] Error fetching profile in store:', e);\n          set({\n            error: e.message || 'Profil alınırken bir hata oluştu.',\n            loading: false,\n          });\n        }\n      },\n      resetProfile: () => set(initialState),\n      updateThrowbackPreferences: async prefs => {\n        const currentUserId = get().id;\n        if (!currentUserId) {\n          set({\n            error: 'User ID not found. Cannot update throwback preferences.',\n            loading: false,\n          });\n          return;\n        }\n        set({ loading: true, error: null });\n        try {\n          // Assuming updateProfileApi can handle partial updates\n          const updatedProfile = await updateProfileApi({\n            id: currentUserId, // Pass the user ID for the update\n            throwback_reminder_enabled: prefs.throwback_reminder_enabled,\n            throwback_reminder_frequency: prefs.throwback_reminder_frequency,\n          });\n          if (updatedProfile) {\n            set({\n              throwback_reminder_enabled:\n                updatedProfile.throwback_reminder_enabled,\n              throwback_reminder_frequency:\n                updatedProfile.throwback_reminder_frequency,\n              loading: false,\n              error: null,\n            });\n          } else {\n            // This case might indicate an issue with updateProfileApi returning null on success\n            // or if the API itself didn't return the full updated profile.\n            // For now, optimistically update state if API doesn't error.\n            set({\n              throwback_reminder_enabled: prefs.throwback_reminder_enabled,\n              throwback_reminder_frequency: prefs.throwback_reminder_frequency,\n              loading: false,\n              error: null,\n            });\n            console.warn(\n              '[profileStore] updateThrowbackPreferences: updateProfileApi returned no data, but no error. State updated optimistically.'\n            );\n          }\n        } catch (e: any) {\n          console.error(\n            '[profileStore] Error updating throwback preferences:',\n            e\n          );\n          set({\n            error: e.message || 'Failed to update throwback preferences.',\n            loading: false,\n          });\n          // Optionally, re-throw or handle more gracefully\n        }\n      },\n      updateDailyReminderSettings: async prefs => {\n        const currentUserId = get().id;\n        if (!currentUserId) {\n          set({\n            error: 'User ID not found. Cannot update daily reminder settings.',\n            loading: false,\n          });\n          return;\n        }\n        set({ loading: true, error: null });\n\n        let finalReminderEnabled = prefs.reminder_enabled;\n\n        try {\n          if (prefs.reminder_enabled) {\n            const permissionGranted = await requestNotificationPermissions();\n            if (permissionGranted) {\n              const [hours, minutes] = prefs.reminder_time\n                .split(':')\n                .map(Number);\n              await scheduleDailyReminder(\n                hours,\n                minutes,\n                'Günlük Minnettarlık Zamanı',\n                'Bugün neleri fark ettin? Yazmaya ne dersin?'\n              );\n            } else {\n              finalReminderEnabled = false; // Permission denied, force disable\n              await cancelAllScheduledNotifications(); // Ensure any old ones are cancelled\n            }\n          } else {\n            await cancelAllScheduledNotifications();\n          }\n\n          const updatedProfile = await updateProfileApi({\n            id: currentUserId,\n            reminder_enabled: finalReminderEnabled,\n            reminder_time: prefs.reminder_time,\n          });\n\n          if (updatedProfile) {\n            set({\n              reminder_enabled: updatedProfile.reminder_enabled,\n              reminder_time: updatedProfile.reminder_time,\n              loading: false,\n              error: null,\n            });\n          } else {\n            // Optimistic update if API returns no data but no error\n            set({\n              reminder_enabled: finalReminderEnabled,\n              reminder_time: prefs.reminder_time,\n              loading: false,\n              error: null,\n            });\n            console.warn(\n              '[profileStore] updateDailyReminderSettings: updateProfileApi returned no data, but no error. State updated optimistically.'\n            );\n          }\n        } catch (e: any) {\n          console.error(\n            '[profileStore] Error updating daily reminder settings:',\n            e\n          );\n          set({\n            error: e.message || 'Failed to update daily reminder settings.',\n            loading: false,\n          });\n        }\n      },\n    }),\n    {\n      name: 'yeser-profile-storage', // unique name\n      storage: createJSONStorage(() => AsyncStorage), // (optional) by default, 'localStorage' is used\n    }\n  )\n);\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/store/themeStore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used. Allowed unused args must match /^_/u.","line":48,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":48,"endColumn":46}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import AsyncStorage from '@react-native-async-storage/async-storage';\nimport { create } from 'zustand';\nimport { createJSONStorage, persist } from 'zustand/middleware';\n\nimport { darkTheme } from '../themes/darkTheme';\nimport { lightTheme } from '../themes/lightTheme';\nimport { AppTheme } from '../themes/types'; // Assuming AppTheme includes a 'name' property\n\ntype ThemeName = 'light' | 'dark';\n\ninterface ThemeState {\n  activeThemeName: ThemeName;\n  activeTheme: AppTheme;\n  setTheme: (themeName: ThemeName) => void;\n  toggleTheme: () => void;\n}\n\nconst getThemeObjectByName = (themeName: ThemeName): AppTheme => {\n  return themeName === 'light' ? lightTheme : darkTheme;\n};\n\nexport const useThemeStore = create<ThemeState>()(\n  persist(\n    (set, get) => ({\n      activeThemeName: 'light', // Default theme\n      activeTheme: lightTheme, // Default theme object\n      setTheme: themeName => {\n        set({\n          activeThemeName: themeName,\n          activeTheme: getThemeObjectByName(themeName),\n        });\n      },\n      toggleTheme: () => {\n        const currentThemeName = get().activeThemeName;\n        const newThemeName = currentThemeName === 'light' ? 'dark' : 'light';\n        set({\n          activeThemeName: newThemeName,\n          activeTheme: getThemeObjectByName(newThemeName),\n        });\n      },\n    }),\n    {\n      name: 'app-theme-storage', // Name of the item in AsyncStorage\n      storage: createJSONStorage(() => AsyncStorage),\n      // Only persist the theme name, not the entire theme object\n      partialize: state => ({ activeThemeName: state.activeThemeName }),\n      // When rehydrating, set the activeTheme object based on the persisted name\n      onRehydrateStorage: () => (state, error) => {\n        if (state) {\n          state.activeTheme = getThemeObjectByName(state.activeThemeName);\n        }\n      },\n    }\n  )\n);\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/store/throwbackStore.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1650,1653],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1650,1653],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import AsyncStorage from '@react-native-async-storage/async-storage';\nimport { create } from 'zustand';\nimport { createJSONStorage, persist } from 'zustand/middleware';\n\nimport { getRandomGratitudeEntry, GratitudeEntry } from '../api/gratitudeApi';\n\ninterface ThrowbackState {\n  lastThrowbackShownAt: number | null; // Timestamp of when a throwback was last shown\n  randomEntry: GratitudeEntry | null;\n  isThrowbackVisible: boolean;\n  isLoading: boolean;\n  error: string | null;\n  fetchRandomEntry: () => Promise<void>;\n  showThrowback: () => void;\n  hideThrowback: () => void;\n  clearError: () => void;\n  setLastThrowbackShown: (timestamp: number) => void;\n  resetThrowback: () => void; // Added reset action\n}\n\nconst initialState: Omit<\n  ThrowbackState,\n  | 'fetchRandomEntry'\n  | 'showThrowback'\n  | 'hideThrowback'\n  | 'clearError'\n  | 'setLastThrowbackShown'\n  | 'resetThrowback'\n> = {\n  randomEntry: null,\n  isThrowbackVisible: false,\n  isLoading: false,\n  error: null,\n  lastThrowbackShownAt: null,\n};\n\nexport const useThrowbackStore = create<ThrowbackState>()(\n  persist(\n    (set, get) => ({\n      ...initialState,\n\n      fetchRandomEntry: async () => {\n        set({ isLoading: true, error: null });\n        try {\n          const entry = await getRandomGratitudeEntry();\n          if (entry) {\n            set({\n              randomEntry: entry,\n              isLoading: false,\n              isThrowbackVisible: true,\n              lastThrowbackShownAt: Date.now(),\n            });\n          } else {\n            set({ randomEntry: null, isLoading: false }); // Ensure randomEntry is null if no entry found\n          }\n        } catch (e: any) {\n          console.error('Error fetching random gratitude entry:', e);\n          set({\n            error: e.message || 'Failed to fetch random entry',\n            isLoading: false,\n            randomEntry: null,\n          });\n        }\n      },\n\n      setLastThrowbackShown: (timestamp: number) => {\n        set({ lastThrowbackShownAt: timestamp });\n      },\n\n      showThrowback: () => {\n        // Only show if there's an entry to display\n        if (get().randomEntry) {\n          set({ isThrowbackVisible: true });\n        }\n      },\n\n      hideThrowback: () => {\n        set({ isThrowbackVisible: false, randomEntry: null }); // Clear entry on hide to ensure next fetch is fresh\n      },\n\n      clearError: () => {\n        set({ error: null });\n      },\n\n      resetThrowback: () => {\n        set(initialState);\n      },\n    }),\n    {\n      name: 'throwback-storage',\n      storage: createJSONStorage(() => AsyncStorage),\n      // Persist only lastThrowbackShownAt. Other states are transient for a session.\n      partialize: state => ({\n        lastThrowbackShownAt: state.lastThrowbackShownAt,\n      }),\n    }\n  )\n);\n","usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/themes/darkTheme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/themes/lightTheme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/themes/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/types/expo-web-browser.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/types/navigation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/types/supabase.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/utils/dateUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/anilkaraca/Desktop/yeser/src/utils/supabaseClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]